```cpp
class Solution {
public:
    int longestOnes(vector<int>& nums, int k) {
        int left = 0;
        int zeroCount = 0;
        int maxLen = 0;

        for (int right = 0; right < nums.size(); right++) {
            if (nums[right] == 0) {
                zeroCount++;
            }
            
            while (zeroCount > k) {
                if (nums[left] == 0) {
                    zeroCount--;
                }
                left++;
            }
            
            int currentLen = right - left + 1;
            maxLen = max(maxLen, currentLen);
        }

        return maxLen;
    }
};

```

In this problem, a binary vector `nums` and an integer `k` are given. The `nums` vector being binary only accepts the values ​​`0` and `1`. The goal is to determine the maximum length of a consecutive subsequence of digits `1` in the vector `nums`, if we can reverse at most `k` zero values ​​in the vector to obtain maximum consecutiveness.

For `nums = [1,1,1,0,0,0,1,1,1,1,0], k = 2`
If in `nums` if we try to return the zero values ​​from positions 3 and 4 (because we are allowed to return only 2 values), we would get a sequence of `1` values ​​from 0 to 4, i.e. 5 values. So we get `nums = [1,1,1,1,1,0,1,1,1,1,0]`
But if we try to return the zeros located on positions 5 and 6, we would get `nums = [1,1,1,0,1,1,1,1,1,1,0]`, that is, a sequence of length 6.
Analogously, if we change the zeros on positions 5 and 10 and get `nums = [1,1,1,0,0,1,1,1,1,1,1]`, we get a solution because there is a sequence of 6 consecutive 1 values.

Since this problem is also about substrings of numbers from a given string that must satisfy certain conditions, I can use the sliding window method again. For this I will define two integer variables `left` and `right` both initialized to zero. The `right` variable will expand the window to the right.
In the variable `zeroCount` I will count how many zeros I have found up to a certain moment. Initially we have none, so the variable will have the value zero.
In the `maxLen` variable I will keep the maximum length of the sequence of values ​​of `1` that I found. The final result of this variable will be the final answer of the problem, so it will have to be returned by the function.

If you are familiar with this algorithm, you already know that it is not extremely difficult.
If you don't know, I will explain here briefly.
The "sliding window technique" could be explained as follows:
--- define two indices, `left` and `right`, which mark the boundaries of a subsequence ("window") in the data string.
--- start from an initial sliding window configuration. In the case of this problem, initialize the values ​​for `left` and `right` to zero.
---The "window" is expanded by moving `right' to the right or `left' to the left.
--- The "window" is contracted by moving `left' to the right or `right' to the left.

A step-by-step approach to solve this problem is:
1. Initialize the variables.
2. The algorithm goes through the algorithm using the sliding window method.
3. The function returns the maximum length of the subsequence of `1s` found with at most `k` inversions of zeros.


So, let's take the steps one at a time.
1. Initialize the variables:
```cpp
        int left = 0;
        int zeroCount = 0;
        int maxLen = 0;
```
I've already discussed what each of the variables in the initialization part of the problem does. I don't think there is any need to dwell on this subject.

2. The algorithm goes through the algorithm using the sliding window method:

```cpp
        for (int right = 0; right < nums.size(); right++) {
            if (nums[right] == 0) {
                zeroCount++;
            }
            
            while (zeroCount > k) {
                if (nums[left] == 0) {
                    zeroCount--;
                }
                left++;
            }
            
            int currentLen = right - left + 1;
            maxLen = max(maxLen, currentLen);
        }
```

I use a loop to traverse the vector `nums` from left to right, using the `right` index.
If `nums[right]` is zero, we increment the `zeroCount` variable.
I check if `zeroCount` is greater than `k`. If so, it means we have too many zeros in the current window. We need to adjust the window to meet the condition.
When `zeroCount > k`, it means we need to contract the sliding window from left to right by moving `left`.
In this case, we increment `left` to shrink the window and decrement `zeroCount` if the element leaving the window is a zero.
As the sliding window is adjusted by expanding and contracting, we will continuously update the maximum length of the substring of `1s` found so far, keeping `maxLen`.
So checking `zeroCount > k` helps us optimize the process of finding the longest substring of `1s` that can be obtained by reversing at most `k` zeros. If the number of zeros exceeds our ability to invert, then we need to adjust the window to search for viable solutions.

I increment the variable `left` to shrink the window, until `zeroCount` becomes less than or equal to `k`.
I calculate the length of the current window `currentLen = right - left + 1`.
I update `maxLen` with `currentLen` if necessary.

3. The function returns the maximum length of the subsequence of `1s` found with at most `k` inversions of zeros:

```cpp
    return maxLen;
```

In conclusion, this algorithm uses a single traversal of the `nums` vector, which makes it efficient with O(n) time complexity, where n is the length of the `nums` vector.
The use of a sliding window allows us also in the case of these problems, to efficiently manage the restriction of inverting a maximum of `k` zeros to obtain the maximum subsequence of consecutive `1s`.

See you in the next video.