```cpp
class Solution {
public:
    bool increasingTriplet(vector<int>& nums) {
        int min1 = INT_MAX, min2 = INT_MAX;
        for (int n : nums) {
            if (n > min2) return true;
            if (n <= min1)
                min1 = n;
            else
                min2 = n;
        }
        return false;
    }
};
```

Hello and welcome to our Algorithmic course, where we will explore and solve interesting problems on LeetCode.

In this problem I receive a collection of integers.
I need to write an algorithm to check if a given vector contains a strictly increasing subsequence of three elements. So if `i < j < k` then `nums[i] < nums[j] < nums[k]`.
If they find such a sequence the answer will be `true` otherwise the answer will be `false`.


For `nums = [0,4,2,1,0,-1,-3]` final respons is `false`
For `nums = [2,1,5,0,4,6]` final respons is `true` because there exists sequence of indices `3 < 4 < 5 ` for which `nums[3] = 0 less than nums[4] = 4 less than nums[5] = 6 `.

If we try to traverse this collection of values ​​by positioning ourselves on the left end of it with a triplet of counters `i=0, j=i+1, k=j+1` and traverse in three `for` loops involved the entire vector from one end to the other, for a small number of data we will get the correct result but for a large number of data the number of operations performed is very high, so the solution is not recommended.

For an optimal traversal of such a collection, we use the simplified range-based script that iterates over the elements of the collection. For each value `n` in the collection `nums`, I determine the two smallest numbers `min1` and `min2`.
By doing this, I go through the vector one man at a time so the efficiency is much better.

A step-by-step approach to solve this problem is:
1. Initializing the variables
2. Traversing the data collection
3. Return the final answer

So, let's take the steps one at a time.
1. Initializing the variables:

```cpp
    int min1 = INT_MAX, min2 = INT_MAX; 
```

Initializes the variables `min 1` and `min2` to the largest possible values ​​from the set of integers, `INT_MAX` - the predefined constant in the `<climits>` library.

2. Traversing the data collection:

```cpp
        for (int n : nums) {
            if (n > min2) return true;
            if (n <= min1)
                min1 = n;
            else
                min2 = n;
        }
```

--- `min1` is set to the smallest number found so far.
--- `min2` is set to the smallest number that is greater than `min1`.
If at some point a number `n` that is greater than `min2` is found, `true` is returned because a strict increasing sequence of three numbers was found.


For `nums = [1,2,3,4,5]`
`n = 1, min1 = 1`
`n = 2, min2 = 2`
`n = 3, n> min2` so return `true`

3. Return the final answer:

If the loop terminates without finding an increasing sequence of three numbers, the function returns `false`.

```cpp
        return false;
```

In conclusion, my algorithm checks if a vector of integers contains a strictly increasing sequence of three numbers. The algorithm uses two variables `min1` and `min2` to keep track of the two smallest values ​​encountered up to each step, and traverses the vector only once. If an element is found and is greater than `min2`, it returns `true`, indicating the existence of such a sequence. If the loop terminates without finding this element, it returns `false`.
Written this way, the algorithm is efficient and fast.

See you in the next video.