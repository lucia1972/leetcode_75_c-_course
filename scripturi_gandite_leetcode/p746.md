```cpp 
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int n = cost.size();
        // Declarăm un array pentru a memora costurile minime până la fiecare treaptă
        vector<int> minimalCost(n, -1);
        
        // Definim o funcție recursivă pentru a calcula costul minim
        function<int(int)> dfs = [&](int i) {
            // Dacă am depășit ultima treaptă, costul este 0
            if (i >= n) {
                return 0;
            }
            // Dacă nu am calculat încă costul pentru treapta i
            if (minimalCost[i] < 0) {
                // Calculăm costul ca fiind costul actual plus costul minim dintre urcarea la treapta următoare sau la a doua treaptă
                minimalCost[i] = cost[i] + min(dfs(i + 1), dfs(i + 2));
            }
            // Returnăm costul calculat pentru treapta i
            return minimalCost[i];
        };
        
        // Calculăm costul minim pornind fie de la prima treaptă, fie de la a doua treaptă
        return min(dfs(0), dfs(1));
    }
};


```

In aceasta problema am un array de numere întregi `cost` unde `cost[i]` reprezintă costul de a urca pe treapta `i` dintr-o scară.
Poți să începi de pe treapta cu indexul `0` sau de pe treapta cu indexul `1`.

Se cere sa returnez costul minim pentru a ajunge în vârful scării.
Pentru aceasta am două opțiuni pentru fiecare treaptă: fie urc o singură treaptă, fie urc două trepte.
Costul pentru a ajunge la o anumită treaptă este suma costurilor treptelor anterioare pe care le-am urcat.
Scopul este să minimizez acest cost pentru a ajunge în vârful scării.

De exemplu `cost = [10,15,20]` 

Pot începe urcusul de la treapta `0`, platesc 10 si ajung pe treapta 1, apoi urc două trepte direct la treapta 2 și plătesc 20. Costul total este 10 + 20 = 30.

Pot începe de la treapta `1`, platesc 15, apoi urc o singură treaptă la treapta 2 și platesc 20. Costul total este 15 + 20 = 35. Deci o valoare mai mare.

Pot începe de la treapta `1`, platesc 15, apoi urc doua trepte si am ajuns in varf. Costul total este 15. Deci o valoare mai mica.

Deci, costul minim pentru a ajunge în vârful scării este 15.

Propun rezolvarea problemei folosind programarea dinamică pentru a memora costurile minime până la fiecare treaptă și pentru a evita recalculările inutile.

Voi folosi de asemenea o funcție recursiva și a unui array de memoizare, pentru a calcula eficient costul minim pentru a urca treptele.

Declar o variabila `n` de tip integer pentru a retine numarul de trepte adica `cost.size()` si un array `minimalCost` initializat pe `-1` folosit pentru a memora costurile minime până la fiecare treaptă. Valoarea de pornire `-1` indica că nu a fost calculata nici o valoare in acea pozitie.

Funcție recursivă `dfs` care calculează costul minim pentru a ajunge la treapta `i`.
Ea primește ca argument o valoarea integer și returnează la final o valoare integer. Variabilele sunt accesate prin referinta ceea ce este indicat prin folosirea `[&]` in definirea functiei. Acest lucru inseamna ca funcția va avea acces direct la aceste variabile și va putea să le modifice dacă este necesar - in cazul nostru are acces la variabilele `n` si `minimalCost`.

Dacă am depășit ultima treaptă (i >= n), returnăm 0 deoarece nu mai este nevoie să urcăm.
Dacă costul pentru treapta i nu a fost calculat încă (f[i] < 0), îl calculăm ca fiind costul actual plus costul minim dintre urcarea la treapta următoare (i + 1) sau la a doua treaptă (i + 2).
Returnăm costul calculat pentru treapta i.
Calculul costului minim:

Apelăm funcția dfs pentru prima și a doua treaptă și returnăm valoarea minimă dintre cele două. Aceasta asigură că putem începe fie de la prima treaptă (0), fie de la a doua treaptă (1).