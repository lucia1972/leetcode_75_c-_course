```cpp 
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int n = cost.size();
        // We declare an array to store the minimum costs up to each step
        vector<int> minimalCost(n, -1);
        
        // We define a recursive function to calculate the minimum cost
        function<int(int)> dfs = [&](int i) {
            // If I passed the last step, the cost is 0
            if (i >= n) {
                return 0;
            }
            // If we have not yet calculated the cost for step i
            if (minimalCost[i] < 0) {
                // We calculate the cost as the current cost plus the minimum cost between moving up to the next step or to the second step
                minimalCost[i] = cost[i] + min(dfs(i + 1), dfs(i + 2));
            }
            // We return the calculated cost for step i
            return minimalCost[i];
        };
        
        // We calculate the minimum cost starting from either the first step or the second step
        return min(dfs(0), dfs(1));
    }
};


```

In aceasta problema am un array de numere întregi `cost` unde `cost[i]` reprezintă costul de a urca pe treapta `i` dintr-o scară.
Poți să începi de pe treapta cu indexul `0` sau de pe treapta cu indexul `1`.

Se cere sa returnez costul minim pentru a ajunge în vârful scării.
Pentru aceasta am două opțiuni pentru fiecare treaptă: fie urc o singură treaptă, fie urc două trepte.
Costul pentru a ajunge la o anumită treaptă este suma costurilor treptelor anterioare pe care le-am urcat.
Scopul este să minimizez acest cost pentru a ajunge în vârful scării.

De exemplu `cost = [10,15,20]` 

Pot începe urcusul de la treapta `0`, platesc 10 si ajung pe treapta 1, apoi urc două trepte direct la treapta 2 și plătesc 20. Costul total este `10 + 20 = 30`.

Pot începe de la treapta `1`, platesc 15, apoi urc o singură treaptă la treapta 2 și platesc 20. Costul total este `15 + 20 = 35`. Deci o valoare mai mare.

Pot începe de la treapta `1`, platesc 15, apoi urc doua trepte si am ajuns in varf. Costul total este `15`. Deci o valoare mai mica.

Deci, costul minim pentru a ajunge în vârful scării este `15`.

Propun rezolvarea problemei folosind programarea dinamică pentru a memora costurile minime până la fiecare treaptă și pentru a evita recalculările inutile.

Voi folosi de asemenea o funcție recursiva și a unui array de memoizare, pentru a calcula eficient costul minim pentru a urca treptele.

**Memoizarea** este o tehnică de optimizare utilizată în principal pentru a accelera calculul funcțiilor recursiv definite stocând rezultatele intermediare. În contextul programării dinamice, memoizarea implică utilizarea unei structuri de date, cum ar fi un array sau un dicționar, pentru a stoca rezultatele calculului unor subprobleme.

În acest algoritm, folosim un array de memoizare pentru a stoca costurile minime necesare pentru a ajunge la fiecare treaptă. Aceasta ne permite să evităm recalcularea costurilor pentru trepte care au fost deja procesate, economisind astfel timp de calcul.

Declar o variabila `n` de tip integer pentru a retine numarul de trepte adica `cost.size()` si un array `minimalCost` initializat pe `-1` folosit pentru a memora costurile minime până la fiecare treaptă. Valoarea de pornire `-1` indica că nu a fost calculata nici o valoare in acea pozitie.

Funcție recursivă `dfs` care calculează costul minim pentru a ajunge la treapta `i`.
Ea primește ca argument o valoarea integer și returnează la final o valoare integer. Variabilele sunt accesate prin referinta ceea ce este indicat prin folosirea `[&]` in definirea functiei. Acest lucru inseamna ca funcția va avea acces direct la aceste variabile și va putea să le modifice dacă este necesar - in cazul nostru are acces la variabilele `n` si `minimalCost`.

Dacă am depășit ultima treaptă (i >= n), returnăm 0 deoarece nu mai este nevoie să urcăm.
Dacă costul pentru treapta i nu a fost calculat încă (f[i] < 0), îl calculăm ca fiind costul actual plus costul minim dintre urcarea la treapta următoare (i + 1) sau la a doua treaptă (i + 2).
Returnăm costul calculat pentru treapta i.
Calculul costului minim:

Apelăm funcția dfs pentru prima și a doua treaptă și returnăm valoarea minimă dintre cele două. Aceasta asigură că putem începe fie de la prima treaptă (0), fie de la a doua treaptă (1).


