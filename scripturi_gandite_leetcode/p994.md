```cpp
class Solution {
public:
    int orangesRotting(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        queue<pair<int, int>> q;
        int freshOranges = 0;
        
        // We initialize the queue with all the rotten oranges and count the fresh oranges
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (grid[i][j] == 2) {
                    q.push({i, j});
                } else if (grid[i][j] == 1) {
                    freshOranges++;
                }
            }
        }
        
        if (freshOranges == 0) return 0; // If there are no fresh oranges, we return 0
        
        vector<int> dirs = {-1, 0, 1, 0, -1};
        int minutes = 0;
        
        // BFS for the spread of infection
        while (!q.empty()) {
            minutes++;
            int size = q.size();
            for (int i = 0; i < size; ++i) {
                auto [x, y] = q.front();
                q.pop();
                for (int d = 0; d < 4; ++d) {
                    int nx = x + dirs[d], ny = y + dirs[d + 1];
                    if (nx >= 0 && ny >= 0 && nx < m && ny < n && grid[nx][ny] == 1) {
                        grid[nx][ny] = 2;
                        q.push({nx, ny});
                        freshOranges--;
                    }
                }
            }
        }
        
        // If there are any fresh oranges left, return -1
        return freshOranges == 0 ? minutes - 1 : -1;
    }
};

```

In aceasta problema primesc o matrice `m x n` care are doar valorile 0, 1 sau 2 unde `0` inseamna o celula goala, `1` inseamna portocala proaspata iar `2` inseamna portocala stricata. In fiecare minut, o portocala buna daca este inconjurata in toate cele 4 directii de portocale stricate se strica si ea.
Trebuie sa gasesc timpul minim in care toate portocalele se strica si daca nu pot returna acest timp, voi returna `-1`.

In mod asemanator cu problema labirintului, si aceasta problema O voi putea modela ca un graf neponderat, unde fiecare celulă din matrice reprezintă un nod, iar legăturile (muchiile) între noduri sunt definite de deplasările posibile (sus, jos, stânga, dreapta).

Voi folosi din nou tehnica `BFS` pentru a explora nodurile la fiecare nivel înainte de a trece la nivelul următor, asigurând găsirea celei mai scurte căi in cautarea numărul minim de minute până când toate portocalele proaspete devin stricate.

Functia `orangesRotting` primeste ca argument o matrice de numere intregi `grid` de tip `vector<vector<int>>` si returneaza o valoare intreaga.
Raspunsul final va fi returnat in `minutes`, daca numarul de minute minime a putut fi calculat sau `-1` in caz contrar.

Variabilele `m` si `n` de tip intreg sunt folosite numai pentru a determina numarul de linii si cel de coloane ale matricii initiale, folosind functia `size()`.
`int m = grid.size(), n = grid[0].size();`

Declar apoi o coada `q` pentru a ține coordonatele portocalelor stricate, iar variavila `freshOranges` o folosesc pentru a numara portocalele proaspete.
```cpp
        queue<pair<int, int>> q;
        int freshOranges = 0;
```
Prima parte a algoritmului consta in popularea cozii in care retin portocalele stricate si numararea portocalelor proaspete.
Parcurg astfel matricea - intr-un mod clasic - cu 2 bucle `for` imbricate, una pentru numarul de linii si una pentru numarul de coloane.
Portocala este proaspata daca valoarea pe care eu o gasesc in matrice este `1` si stricata daca valoarea gasita este `2`.
In urma acestei parcurgeri a matricii, daca `grid[i][j]` adica pozitia curenta din matrice are valoarea `2` inseamna ca acolo este o portocala styricata si trebuie sa adaug coordonatele acelei pozitii in coada q, `q.push({i, j});`, altfel, daca valoarea este `1`, incrementez variabila `freshOranges`. Atat de simplu si clar!

Coada (queue) este o structură de date esențială care ajută la gestionarea ordinii în care sunt procesate nodurile - celule matricii in cazul dat si funcționează pe principiul `FIFO` (First In, First Out), adică elementele sunt procesate în ordinea în care sunt adăugate.
Funcția `push` pe care eu am folosit-o aici, este o metodă a clasei `<queue>` din biblioteca standard C++ și este utilizată pentru a adăuga elemente la sfârșitul cozii. În acest caz, adăugăm perechi de coordonate `{i, j}` la coada `q`.

```cpp
// We initialize the queue with all the rotten oranges and count the fresh oranges
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (grid[i][j] == 2) {
                    q.push({i, j});
                } else if (grid[i][j] == 1) {
                    freshOranges++;
                }
            }
        }
```

Daca in urma acestei parcurgeri, `if (freshOranges == 0) return 0; // If there are no fresh oranges, we return 0` nu am gasit portocale proaspete, atunci returnez 0 pentru ca nu voi avea nevoie sa determin un timp minim pana la care ele se strica. Ele nu exista.

Daca exista cel putin o portocala proaspata deci ` freshOranges != 0`, imi continui algoritmul.

Initializez un vector de deplasare in spatiu `vector<int> dirs = {-1, 0, 1, 0, -1};` pentru a retine calculul noilor poziții pe baza direcțiilor (sus, jos, stânga, dreapta).

Deci asa voi simplifica calculul noilor coordonate `(x, y)` atunci când ma deplasez de la o celulă la alta în cele patru direcții posibile: sus, jos, stânga și dreapta. Secvența de valori care reprezintă schimbările de coordonate pentru deplasarea în cele patru direcțiivor fi utilizate pentru a calcula noile poziții `(x, y)` prin adunarea valorilor corespunzătoare la coordonatele curente.

`dirs[0]` și `dirs[1]` sunt utilizate pentru deplasarea în sus.
`dirs[1]` și `dirs[2]` sunt utilizate pentru deplasarea la dreapta.
`dirs[2]` și `dirs[3]` sunt utilizate pentru deplasarea în jos.
`dirs[3]` și `dirs[4]` sunt utilizate pentru deplasarea la stânga.

Utilizarea acestui array reduce complexitatea codului și face algoritmul mai ușor de citit și de înțeles. Aceasta abordare este comună în problemele de parcurgere a grafului, cum ar fi cele care implică labirinturi sau matrici, unde deplasarea în direcții fixe este necesară.

Numarul de minute pe care trebuie sa le calculez, `int minutes = 0;` este initial zero.

Incep sa parcurg coada creata anterior pentru a vedea cum se imprastie infectia intre portocale.
Cat timp coada mai are inca elemente, iau un element, il prelucrez si il sterg din coada folosind `q.pop()`.

Deci, in fiecare iteratie, incrementez numarul de minute.

```cpp 
// BFS for the spread of infection
    while (!q.empty()) {
        minutes++;
        int size = q.size();
        for (int i = 0; i < size; ++i) {
            auto [x, y] = q.front();
            q.pop();
            for (int d = 0; d < 4; ++d) {
                int nx = x + dirs[d], ny = y + dirs[d + 1];
                if (nx >= 0 && ny >= 0 && nx < m && ny < n && grid[nx][ny] == 1) {
                    grid[nx][ny] = 2;
                    q.push({nx, ny});
                    freshOranges--;
                }
            }
        }
    }

```

Folosind o bucla `for`, procesez fiecare portocală stricată și vad cum are loc raspandirea infecției la portocalele proaspete adiacente.
Marcam portocalele proaspete infectate ca stricate și le adăugăm în coadă.
Folosind `q.front()` iau portacala din varful cozii - elementul curent pentru ca `front()` imi returneaza o referință la primul element din coadă fără a-l elimina.

Elementele din coadă sunt perechi de coordonate `{i, j}`. Deci, `x` va primi valoarea `i`, iar `y` va primi valoarea `j`.

