```cpp
class Solution {
public:
    int orangesRotting(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        queue<pair<int, int>> q;
        int freshOranges = 0;
        
        // We initialize the queue with all the rotten oranges and count the fresh oranges
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (grid[i][j] == 2) {
                    q.push({i, j});
                } else if (grid[i][j] == 1) {
                    freshOranges++;
                }
            }
        }
        
        if (freshOranges == 0) return 0; // If there are no fresh oranges, we return 0
        
        vector<int> dirs = {-1, 0, 1, 0, -1};
        int minutes = 0;
        
        // BFS for the spread of infection
        while (!q.empty()) {
            minutes++;
            int size = q.size();
            for (int i = 0; i < size; ++i) {
                auto [x, y] = q.front();
                q.pop();
                for (int d = 0; d < 4; ++d) {
                    int nx = x + dirs[d], ny = y + dirs[d + 1];
                    if (nx >= 0 && ny >= 0 && nx < m && ny < n && grid[nx][ny] == 1) {
                        grid[nx][ny] = 2;
                        q.push({nx, ny});
                        freshOranges--;
                    }
                }
            }
        }
        
        // If there are any fresh oranges left, return -1
        return freshOranges == 0 ? minutes - 1 : -1;
    }
};

```

In aceasta problema primesc o matrice `m x n` care are doar valorile 0, 1 sau 2 unde `0` inseamna o celula goala, `1` inseamna portocala proaspata iar `2` inseamna portocala stricata. In fiecare minut, o portocala buna daca este inconjurata in toate cele 4 directii de portocale stricate se strica si ea.
Trebuie sa gasesc timpul minim in care toate portocalele se strica si daca nu pot returna acest timp, voi returna `-1`.

In mod asemanator cu problema labirintului, si aceasta problema O voi putea modela ca un graf neponderat, unde fiecare celulă din matrice reprezintă un nod, iar legăturile (muchiile) între noduri sunt definite de deplasările posibile (sus, jos, stânga, dreapta).

Voi folosi din nou tehnica `BFS` pentru a explora nodurile la fiecare nivel înainte de a trece la nivelul următor, asigurând găsirea celei mai scurte căi in cautarea numărul minim de minute până când toate portocalele proaspete devin stricate.

Inițializare:

Parcurgem grila pentru a găsi toate portocalele stricate inițiale. Acestea vor fi punctele de start pentru BFS.
De asemenea, numărăm totalul portocalelor proaspete.
Executarea BFS:

Folosim o coadă pentru a procesa portocalele stricate.
La fiecare pas al BFS, marchem portocalele proaspete adiacent strictate și le adăugăm în coadă.
Incrementăm contorul de minute pentru fiecare nivel procesat în BFS.
Verificare Finală:

Dacă toate portocalele proaspete au fost stricate, returnăm numărul de minute.
Dacă rămân portocale proaspete, returnăm -1.