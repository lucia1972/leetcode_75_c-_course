```cpp
class Solution {
public:
    int tribonacci(int n) {
        long long t0=0,t1=1,t2=1,t3,i;
        if(n==0)return 0;
        if(n==1)return 1;
        if(n==2)return 1;
        for(i=1;i<=n-2;i++){
            t3=t0+t1+t2;
            t0=t1;
            t1=t2;
            t2=t3;
        }
        return t3;
    }
};

```
______________________________________
sa ma intrebi cand ajungi aici ce idee de grafica am
_____________________________________



Problema `N-th Tribonacci Number` este o problema foarte asemanatoare cu algoritmul clasic care determina al `n`-lea termen al sirului lui Fibonacci.

Sirul lui Fibonacci este o secvență celebră în matematică, definită astfel:

`F0 = 0`
`F1 = 1`
`Fn = Fn-1 + Fn-2 pentru n ≥ 2`

Cu alte cuvinte, fiecare termen al secvenței Fibonacci este suma celor două termene precedente.

In cazul determinarii termenului `n` pentru secventa Tribonacci, aici termenii sunt definiti astfel:

`T0 = 0`
`T1 = 1`
`T2 = 1`
`Tn = Tn-1 + Tn-2 + Tn-3 pentru n ≥ 3`

Secvența Tribonacci este similară cu secvența Fibonacci, dar în loc să înceapă cu două valori și să adauge două numere precedente pentru a obține următorul număr, secvența Tribonacci începe cu trei valori și adaugă trei numere precedente pentru a obține următorul număr.

Sigur ca, putem elabora un algoritm foarte asemanator cu cel binecunoscut de la implementarea sirului lui Fibonacci pentru calcularea termenului `Tn` al sirului lui Tribonacci.

Declar pentru inceput patru variabile `t0`, `t1`, `t2` și `t3` pentru a stoca valorile numerelor Tribonacci. De asemenea, am declarat variabila `i` pentru iterații.
`long long t0 = 0, t1 = 1, t2 = 1, t3, i;`

Cazurile particulare sunt:

```cpp 
    if(n==0)return 0;
    if(n==1)return 1;
    if(n==2)return 1;

```

Dacă `n` este `0`, `1` sau `2`, funcția returnează direct valoarea corespunzătoare din secvența Tribonacci, deoarece acestea sunt cazurile de bază adica termenii `T0`, `T1` si `T2` sunt deja definiti in ipoteza problemei.

In continuare, pentru calcularea termenilor seriei voi folosi o bucla `for` care iterează de la `1` până la `n-2`, deoarece primii trei termeni sunt deja cunoscuti și nu trebuie recalculate valorile lor.

În fiecare iterație, se calculează următorul termen `t3` ca suma celor trei termene precedente `t0 + t1 +t2`, dupa care cei 3 termeni sunt reactualizati:

`t0` devine `t1`

`t1` devine `t2`

`t2` devine `t3`

Principiul este inspirat din algoritmul Fibonacci.

Astfel, la următoarea iterație, se folosesc valorile corecte pentru a calcula următorul termen în secvență.

In final voi returna ultima valoare retinuta in `t3` pentru ca ea va fi valoarea termenului `n` al sirului.

Pentru `n = 7` voi avea de efectuat 5 iteratii

Iteratia 1 `t0 = 0`, `t1 = 1`, `t2 = 1` si `t3 = 0 + 1 + 1 = 2` si dupa actualizare `t0 = 1`, `t1 = 1`, `t2=2`

Iteratia 2 `t0 = 1`, `t1 = 1`, `t2 = 2` si `t3 = 1 + 1 + 2 = 4` si dupa actualizare `t0 = 1`, `t1 = 2`, `t2=4`

Iteratia 3 `t0 = 1`, `t1 = 2`, `t2 = 4` si `t3 = 1 + 2 + 4 = 7` si dupa actualizare `t0 = 2`, `t1 = 4`, `t2 = 7`

Iteratia 4 `t0 = 2`, `t1 = 4`, `t2 = 7` si `t3 = 2 + 4 + 7 = 13` si dupa actualizare `t0 = 4`, `t1 = 7`, `t2 = 13`

Iteratia 5 `t0 = 4`, `t1 = 7`, `t2 = 13` si `t3 = 4 + 7 + 13 = 24` si dupa actualizare `t0 = 7`, `t1 = 13`, `t2 = 24`

Deci am terminat si returnez `24` care este a 7-a valoare din sir.
Daca vreau sa vad intregul sir el este `0 1 1 2 4 7 13 24`.

Această abordare este eficientă și directă pentru calcularea numerelor Tribonacci. Prin utilizarea unei bucle `for`, am evitat recursivitatea, care ar putea duce la suprasolicitarea stivei pentru valori mari ale lui `n`.

În schimb, folosind variabile pentru a stoca valorile intermediare, am reușit să mențin complexitatea temporală a algoritmului la `O(n)`, ceea ce este suficient de rapid pentru majoritatea cazurilor de utilizare practică.