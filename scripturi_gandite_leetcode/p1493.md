```cpp
int longestSubarray(vector<int>& nums) {
    int left = 0;
    int zero_count = 0;
    int max_length = 0;

    // Iterate over the array with the right pointer
    for (int right = 0; right < nums.size(); right++) {
        // If we encounter a zero, increment the zero_count
        if (nums[right] == 0) {
            zero_count++;
        }
        
        // If we have more than one zero, shrink the window from the left
        while (zero_count > 1) {
            if (nums[left] == 0) {
                zero_count--;
            }
            left++;
        }
       
        // Calculate the current window length
        int current_length = right - left + 1;
        
        // Update the maximum length (we subtract 1 to account for the required deletion)
        max_length = max(max_length, current_length - 1);
    }

    return max_length;
    }

```
Hello and welcome to our Algorithmic course, where we will explore and solve interesting problems on LeetCode.


In this problem I have an array of binary values ​​`nums`. This vector will only receive values ​​of `0` or `1`. I need to determine the longest sequence of values ​​of `1` in the string, if I am allowed to remove a single value of `0`. I am asked to return an integer that represents the length of the maximum sequence.

For `nums = [1,1,1]` the answer will be 3 because I have no `0` value to remove and the whole sequence of `nums` is a sequence of `1` values.
For `nums = [1,1,0,1]` the expected answer is again 3. If I remove the single null value from position 2 of the array, I get a sequence of 3 `1` values.
For `nums = [0,1,1,1,0,1,1,0,1]` the expected answer is 5 because if I remove the value `0` from position 1, I get a sequence of 2 values ​​of `1` , but if I remove the value from position 4, I get a sequence of 5 values ​​of `1`.

To solve the problem I will use the sliding window method.
If you are not yet familiar with this technique, I will explain it here in a few words:
--- I will consider two variables `left` and `right`. Initially both are set to position 0 of the vector. They will determine the size of my sliding values ​​window.
--- to expand the window, so to add new elements to the window, I will move `right` to the right.
--- I will permanently control by counting the number of null values ​​in the array in the `zero_count` variable;
--- if `zero_count` exceeds 1 (ie there is more than one zero in the current window), we move the pointer from left to right to shrink the window until `zero_count` is at most 1.
--- in each iteration of the loop, I will calculate the window size that will also represent the length of my sequence of values ​​of `1` (in the `current_length` variable) and I will update the maximum of all these sequence lengths that I calculate (`max_length`).

A step-by-step approach to solve this problem is:
1. Initialization of variables.
2. The algorithm slide the window from the beginning to the end of the array. For each new position of the window, update the window `zero_count` by subtracting the element that is leaving the window and adding the element that is entering the window. I update the maximum length of secquence if necessary.
3. The function returns returns the maximum length of the sequence of values ​​of `1`.

So, let's take the steps one at a time.
1. Initialization of variables:
```cpp
    int left = 0;
    int zero_count = 0;
    int max_length = 0;
```
I need 3 variables initialized to zero from the beginning of the algorithm:
--- `left` - represents the beginning of the sliding window;
--- `zero_count` - counter for the number of null values ​​in the array;
--- `max_length` - the maximum length of the sequence of non-zero values ​​in the array.

2. The algorithm slide the window from the beginning to the end of the array. For each new position of the window, update the window `zero_count` by subtracting the element that is leaving the window and adding the element that is entering the window. I update the maximum length of secquence if necessary:

```cpp
    // Iterate over the array with the right pointer
    for (int right = 0; right < nums.size(); right++) {
        // If we encounter a zero, increment the zero_count
        if (nums[right] == 0) {
            zero_count++;
        }
        
        // If we have more than one zero, shrink the window from the left
        while (zero_count > 1) {
            if (nums[left] == 0) {
                zero_count--;
            }
            left++;
        }
       
        // Calculate the current window length
        int current_length = right - left + 1;
        
        // Update the maximum length (we subtract 1 to account for the required deletion)
        max_length = max(max_length, current_length - 1);
    }
```

The `right` variable iterates over the array.
For each element at `nums[right]`, if it is zero, increment the `zero_count` variable.
If `zero_count` exceeds 1 (indicating more than one zero in the current window), we need to shrink the window from the `left` until `zero_count` is at most 1.
Move the `left` variable to the right, and if the element at `nums[left]` is zero, decrement the `zero_count`variable.
I calculate the current length of the window, i.e. `right - left + 1`.
Since I need to remove an element, the effective length of the non-null subset is `current_length - 1`.
In each iteration, I have to update the variable in which I keep the maximum length of the sequence of non-zero values ​​in the array with the maximum value between current `max_length` and `current_length - 1`.

3. The function returns returns the maximum length of the sequence of values ​​of `1`:

```cpp
    return max_length; 
```
The function returns the maximum length of the subarray containing only 1's after removing one element.

In conclusion, the algorithm uses the sliding window technique to find the maximum length of a substring of `1s` from a binary vector after removing one element. By maintaining a dynamic window and counting zeros, the algorithm ensures that each element is processed only once, providing an efficient and optimal solution with `O(n)` time complexity and `O(1)` space complexity.

See you in the next video.