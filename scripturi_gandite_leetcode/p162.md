```cpp
class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        int left = 0;
        int right = nums.size() - 1;
        
        while (left < right) {
            int mid = left + (right - left) / 2;
            
            if (nums[mid] > nums[mid + 1]) {
                right = mid; // we search the left side, including mid
            } else {
                left = mid + 1; // search on the right side, excluding mid
            }
        }
        
        return left; // or right, since left == right at the end
    }
};

```

For an array of integers given `nums`, I have to write an optimized algorithm that will run in `O(log n)` to determine in which positions in the array you find peak elements.

A vertex element is an integer strictly larger than its neighbors.

For `nums = [1,1,0,3,5,6,4]` I will return `5` because `nums[5] = 6` is strictly greater than `nums[4] = 5` and ` nums[6] = 4`.

To meet the stated requirements, I will again use the binary search technique because it allows me to halve the search interval at each step, ensuring that the running time of the algorithm is logarithmic.

I will initialize two variables, `left` and `right`, to represent the bounds of the search range. `left` is set to the beginning of the array, and `right' to the end of the array.


```cpp
int left = 0;
int right = nums.size() - 1;
```

As long as the `left < right` condition is respected, I will go through the `nums` array and at each iteration I will calculate the middle of the search interval in the `mid` variable - `int mid = left + (right - left) / 2;` .

Then I compare the neighboring elements

```cpp
    if (nums[mid] > nums[mid + 1]) {
        right = middle;
    } else {
        left = middle + 1;
    }

```

If the middle element `nums[mid]` is greater than its right element `nums[mid + 1]`, then I can have a top element on the left side of the current range, including the `mid` element. So I change the right limit `right` to `mid`.

If `nums[mid]` is less than or equal to `nums[mid + 1]`, then I can have a top element on the right side of the current range, excluding the `mid` element. So I change the left limit `left` to `mid + 1`.

I continue this process until the search range is not empty, i.e. `left` is smaller than `right'.

For `nums = [1,1,0,3,5,6,4]`
`left = 0`, `right = 6`
The search range is `[0, 6]`

Iteration 1
`mid = left + (right - left) / 2 = 0 + 6/2 = 3`
`nums[mid] = nums[3] = 3`, `nums[mid+1] = nums[4] = 5`
`nums[mid] > nums[mid + 1]` false so `left = mid + 1 = 4`
The new search range is `[4, 6]`

Iteration 2
`mid = left + (right - left) / 2 = 4 + (6-4)/2 = 5`
`nums[mid] = nums[5] = 6`, `nums[mid+1] = nums[6] = 4`
`nums[mid] > nums[mid + 1]` true so `right = mid = 5`
The new search range is `[4, 5]`

Iteration 3
`mid = left + (right - left) / 2 = 4 + (5-4)/2 = 4`
`nums[mid] = nums[4] = 5`, `nums[mid+1] = nums[5] = 6`
`nums[mid] > nums[mid + 1]` false so `left = mid + 1 = 5`


The new search interval is `[5, 5]` and the running condition of the `while` loop, namely `left < right`, is no longer respected. So the loop stops.

Finally, I will return the value retained in `left` because there I will find the vars element from the initial array.

So I have exemplified how to go through the array using binary search.
Halving the search interval at each iteration narrows the number of values, which increases the efficiency of the peak search.

In conclusion, the problem of finding a peak element in an array can be efficiently solved using binary search. The algorithm uses two bounds, `left` and `right`, to delimit the search range, which it halves in each iteration. Thus, each step of the algorithm involves checking the element in the middle of the current range and adjusting the bounds based on its relationship to its neighbors.

By applying binary search, I guarantee an `O(log n)` time complexity, which makes the algorithm suitable for large arrays. The illustrated code demonstrates how I can implement this technique to efficiently find a vertex and return its index, ensuring that the algorithm is robust and performant.

The use of binary search in this problem highlights the advantages of this technique for search and selection problems in ordered or partially ordered collections, providing an efficient and elegant solution for identifying a peak element in an array.




Pentru un array de numere intregi dat `nums` trebuie sa scriu un algoritm optimizat care sa ruleze in `O(log n)` pentru a determina pe ce pozitii din array gasesti elemente varfuri.

Un element varf este un integer strict mai mare decat vecinii sai.

Pentru `nums = [1,1,0,3,5,6,4]` voi returna `5` pentru ca `nums[5] = 6` este strict mai mare decat `nums[4] = 5` si `nums[6] = 4`.

Pentru a ma incadra in cerintele enuntate, voi folosi din nou tehnica de căutare binară pentru ca imi permite să reduc intervalul de căutare la jumătate la fiecare pas, asigurandu-mi timpul de rulare al algoritmului sa fie logaritmic.

Voi inițializa două variabile, `left` și `right`, pentru a reprezenta limitele intervalului de căutare. `left` este setat pe începutul array-ului, iar `right` pe finalul array-ului.


```cpp
int left = 0;
int right = nums.size() - 1;
```

Cat timp se respecta conditia `left < right`, voi parcurge arry-ul `nums` si la fiecare iteratie voi calcula mijlocul intervalului de cautare in variabila `mid` - `int mid = left + (right - left) / 2;`.

Apoi compar intre ele elementele vecine 

```cpp
    if (nums[mid] > nums[mid + 1]) {
        right = mid;
    } else {
        left = mid + 1;
    }

```

Dacă elementul de la mijloc `nums[mid]` este mai mare decât elementul său din dreapta `nums[mid + 1]`, atunci pot avea un element de vârf în partea stângă a intervalului curent, inclusiv elementul `mid`. Modific deci limita dreaptă `right` la `mid`.

Dacă `nums[mid]` este mai mic sau egal cu `nums[mid + 1]`, atunci pot avea un element de vârf în partea dreaptă a intervalului curent, exclusiv elementul `mid`. Modific deci limita stângă `left` la `mid + 1`.

Continui acest proces pana cand intervalul de căutare nu este gol adica `left` este mai mic decât `right`.

Pentru `nums = [1,1,0,3,5,6,4]`
`left = 0`, `right = 6`
Intervalul de cautare este `[0, 6]`

Iteratia 1
`mid = left + (right - left) / 2 = 0 + 6/2 = 3`
`nums[mid] = nums[3] = 3`, `nums[mid+1] = nums[4] = 5`
`nums[mid] > nums[mid + 1]` false deci `left = mid + 1 = 4`
Noul interval de cautare este `[4, 6]`

Iteratia 2
`mid = left + (right - left) / 2 = 4 + (6-4)/2 = 5`
`nums[mid] = nums[5] = 6`, `nums[mid+1] = nums[6] = 4`
`nums[mid] > nums[mid + 1]` true deci `right = mid = 5`
Noul interval de cautare este `[4, 5]`

Iteratia 3
`mid = left + (right - left) / 2 = 4 + (5-4)/2 = 4`
`nums[mid] = nums[4] = 5`, `nums[mid+1] = nums[5] = 6`
`nums[mid] > nums[mid + 1]` false deci `left = mid + 1 = 5`
Noul interval de cautare este `[5, 5]` si nu se mai respecta conditia de rulare a buclei `while` si anume `left < right`. Deci bucla se opreste.

In final, voi returna valoarea retinuta in `left` pentru ca acolo voi gasi elementul vars din array-ul initial.

Am exemplificat deci cum parcurg array-ul folosind cautarea binara.
Injumatatirea la fiecare iteratie a intervalului de cautare restrange numarul de valori ceea ce creste eficienta cautarii varfului.

În concluzie, problema găsirii unui element de vârf într-un array poate fi rezolvată eficient folosind căutarea binară. Algoritmul utilizează două limite, `left` și `right`, pentru a delimita intervalul de căutare, pe care îl reduce la jumătate în fiecare iterație. Astfel, fiecare pas al algoritmului implică verificarea elementului de la mijlocul intervalului curent și ajustarea limitelor în funcție de relația acestuia cu vecinii săi.

Prin aplicarea căutării binare, garantez o complexitate de timp `O(log n)`, ceea ce face algoritmul potrivit pentru array-uri mari. Codul ilustrat demonstrează cum pot implementa această tehnică pentru a găsi eficient un element de vârf și a returna indexul său, asigurându-ne că algoritmul este robust și performant.

Utilizarea căutării binare în această problemă evidențiază avantajele acestei tehnici pentru problemele de căutare și selecție în colecții ordonate sau parțial ordonate, oferind o soluție eficientă și elegantă pentru identificarea unui element de vârf într-un array.