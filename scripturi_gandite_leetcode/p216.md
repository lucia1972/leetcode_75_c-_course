nu este gata trebuie reluata


```cpp
class Solution {
public:
    vector<vector<int>> combinationSum3(int k, int n) {
        vector<vector<int>> response;
        vector<int> t;
        function<void(int, int)> backtr = [&](int i, int s) {
            if (s == 0) {
                if (t.size() == k) {
                    response.emplace_back(t);
                }
                return;
            }
            if (i > 9 || i > s || t.size() >= k) {
                return;
            }
            t.emplace_back(i);
            backtr(i + 1, s - i);
            t.pop_back();
            backtr(i + 1, s);
        };
        backtr(1, n);
        return response;
    }
};

```

Trebuie să găsim toate combinațiile valide de `k` numere care însumează `n`, respectând următoarele condiții:

Sunt utilizate doar numerele de la `1` la `9`.
Fiecare număr este utilizat cel mult o dată.
Lista combinațiilor valide nu trebuie să conțină combinații duplicate și poate fi returnată în orice ordine.

Vom folosi o abordare recursivă (backtracking) pentru a explora toate combinațiile posibile și a construi răspunsul final.
Initializam un vector de valori intregi `response` si o variabila temporara `t`.

Functia recursiva `backtr` primește doi parametri: indexul curent `i` și suma curentă `s`.

Dacă `s` devine 0 și am selectat exact `k` numere, adăugăm combinația curentă la lista de răspunsuri `response`.
Trebuie sa facem cateva verificari:
---> dacă `i` este mai mare decat 9 adica nu mai sunt numere valide pe care le-ai putea adauga,
---> daca `i` este mai mare decât `s` adica înseamnă că nu putem adăuga i la combinația curentă fără să depășim suma n,
---> daca am selectat deja `k` numere prin `t.size() >= k` si daca am mai adauga in plus, combinatia ar depasi `k`
ne oprim din explorare.

In pasul urmator,fac 4 operatii distincte pentru a gasi toate combinațiile valide de k numere care însumează n folosind numere de la 1 la 9, respectând constrângerile problemei. Verificările și recursivitatea permit explorarea eficientă a tuturor posibilităților și filtrarea celor nevalide.

Adăugăm numărul i la combinația curentă și apelăm recursiv dfs cu următorul index și suma actualizată.
Eliminăm ultimul număr adăugat și explorăm combinațiile fără acest număr.
Funcția principală combinationSum3:

Inițializează vectorul ans pentru a stoca combinațiile valide și vectorul t pentru combinația curentă.
Apelează funcția dfs începând de la indexul 1 și suma n.

Explicația codului:
Verificările inițiale: Verificăm dacă suma s a devenit 0 și dacă dimensiunea vectorului t este k. Dacă da, adăugăm combinația curentă la vectorul de răspunsuri.
Oprirea recursivității: Dacă i depășește 9, i este mai mare decât s, sau dimensiunea vectorului t a ajuns la k, ne oprim.
Adăugarea și eliminarea elementelor: Adăugăm numărul i la combinația curentă, apelăm recursiv dfs, apoi eliminăm numărul pentru a explora alte combinații.
Acest algoritm generează toate combinațiile posibile într-un mod eficient, respectând condițiile date.