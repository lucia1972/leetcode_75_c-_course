```cpp
class Solution {
public:
    int pivotIndex(vector<int>& nums) {
        for(int i=0;i<nums.size();i++){
            int currentLeftSum=0;
            int currentRightSum=0;
            //We calculate the sum of the elements to the left of i
            for(int j=0;j<i;j++){
                currentLeftSum+=nums[j];
            }

            //We calculate the sum of the elements to the right of i
            for(int j=i+1;j<nums.size();j++){
                currentRightSum+=nums[j];
            }
            
            //We check if the left and right sums are equal
            if(currentRightSum==currentLeftSum){
                // Return the pivot index if the condition is met
                return i;
            }
        }
        return -1;// Return -1 if there is no pivot
    }
};
```

!!!!!!!!!!!!!!!!REFACUT IN PARTEA DE JOS!!!!!!!!!!!!!!!

In this problem I receive a vector of integer values ​​and I am asked to return the power of the element in the vector (if it exists) that has the sum of the elements on its left identical to the sum of the elements on its right.
To solve this problem, I propose to go through the vector once from one end to the other and check the condition required by the problem for each individual element. If there is an element for which the condition of the problem is `true`, I return the index of the element. If the element does not exist, I am obliged to return `-1`.

For: `nums = [1,7,3,6,5,6]`:
`i = 0`: `currentLeftSum = 0`, `currentRightSum = 27`
`i = 1`: `currentLeftSum = 1`, `currentRightSum = 20`
`i = 2`: `currentLeftSum = 8`, `currentRightSum = 17`
`i = 3`: `currentLeftSum = 11`, `currentRightSum = 11` => `return 3`

For: `nums = [1,2,3]`:
`i = 0`: `currentLeftSum = 0`, `currentRightSum = 5`
`i = 1`: `currentLeftSum = 1`, `currentRightSum = 3`
`i = 2`: `currentLeftSum = 3`, `currentRightSum = 0`
=> `return -1` because there is no index that satisfies the conditions in the problem statement.


A step-by-step approach to solve this problem is:
1. Complete vector transversal.
2. Calculate the `currentLeftSum` and `currentRightSum` in each iteration.
3. Return the index for the pivot element.

So, let's take the steps one at a time.
1.Complete vector transversal:

I need two variables in this algorithm:
--- `currentLeftSum` variable which calculate the left sum for the element on the `i` position;
--- `currentRightSum` variable which calculate the right sum for the element on the `i` position.
These variables must be initialized to zero at the beginning of each iteration.

2. Calculate the `currentLeftSum` and `currentRightSum` in each iteration:

```cpp
    for(int j=0;j<i;j++){
        currentLeftSum+=nums[j];
    }
    for(int j=i+1;j<nums.size();j++){
        currentRightSum+=nums[j];
    }

```
For each element in the vector at position `i` I will use an iterator `j` that will go from 0 to the element at position `i-1` and calculate the `currentLeftSum` for element `i`.
Using the same iterator (no need to introduce a new iterator), I go with it this time from `i+1` to the right end of the vector (`nums.size()`) and calculate `currentRightSum`.
For each individual iteration, I check the condition required by the problem. If the two calculated values ​​are equal, it means that I have found a pivot element on the `i` position that I am returning.
If I reach the end of the vector and the condition was never met, it means I don't have a pivot element and I will return `-1`.

3. Return the maximum altitude:
```cpp
    if(currentRightSum==currentLeftSum){return i;}
    //} end of for loop
    return -1;
```

This is one solution to the problem, but to improve efficiency, one can use a single path of the vector to calculate the total sum and then traverse it to determine the left and right partial sum at each step.

```cpp
class Solution {
public:
    int pivotIndex(vector<int>& nums) {
        int sum=0;
        for(int i=0;i<nums.size();i++){
            sum+=nums[i];
        }
        for(int i=0;i<nums.size();i++){
            int currentLeftSum=0;
            for(int j=0;j<i;j++){
                currentLeftSum+=nums[j];
            }
            if(sum-currentLeftSum-nums[i]==currentLeftSum){return i;}
        }
        return -1;
    }
};

```

Iterates over the nums vector to calculate the total `sum` of the elements.
Iterates through the vector again, keeping a partial sum `currentLeftSum`.
At each step, it checks that `currentLeftSum` is equal to `sum-currentLeftSum-nums[i]` (which is the sum of the elements on the right).
If the condition is met, the current index `i` is returned.
If no such pivot index exists, `-1` is returned.

In conclusion, the original solution given for finding the pivot index in a vector iterates through each element and checks that the sum of the elements on the left is equal to the sum of the elements on the right.

To improve efficiency, you can calculate the total vector sum once and then use a single traversal to determine the left and right sums dynamically:

The improved solution has a time complexity of O(n) due to two simple traversals of the vector.
It also has O(1) space complexity because it only uses a few extra variables.

The original solution solves the problem correctly, but can be optimized. The improved solution demonstrates how calculating cumulative sums and maintaining a dynamic left sum can increase efficiency, making the solution more suitable for larger datasets.




!!!!!!!!!!!!!!!!!refacut!!!!!!!!!!!!!!!!!
The problem asks to calculate and return the index of a pivot in an array of integers `nums`.

A pivot is defined as an index in the array for which the sum of the elements on the left is equal to the sum of the elements on the right. If there is no such index, the function returns `-1`.

For: `nums = [1,7,3,6,5,6]`:
`i = 0`: `currentLeftSum = 0`, `currentRightSum = 27`
`i = 1`: `currentLeftSum = 1`, `currentRightSum = 20`
`i = 2`: `currentLeftSum = 8`, `currentRightSum = 17`
`i = 3`: `currentLeftSum = 11`, `currentRightSum = 11` => `return 3`

For: `nums = [1,2,3]`:
`i = 0`: `currentLeftSum = 0`, `currentRightSum = 5`
`i = 1`: `currentLeftSum = 1`, `currentRightSum = 3`
`i = 2`: `currentLeftSum = 3`, `currentRightSum = 0`
=> `return -1` because there is no index that satisfies the conditions in the problem statement.

The algorithm proposed by me performs a complete traversal of the array along its entire length `for (int i = 0; i < nums.size(); i++) {` using a `for` loop. The variable `i` represents the current index that we evaluate to determine if it is a pivot.

```cpp
int currentLeftSum = 0;
int currentRightSum = 0;
```

I then initialize two temporary variables, `currentLeftSum` and `currentRightSum`, to `0` to store the sums of the elements to the left and right of the current index `i`.


Using an index variable `j`, I go through the array from the beginning to before the current position `i` and add all the elements to the left of the element at position `i` in `currentLeftSum`.

```cpp
for (int j = 0; j < i; j++) {
    currentLeftSum += nums[j];
}
```
In an absolutely similar way, starting from the successor of the element on position `i` to the end of the array, I calculate the sum of the elements to the right of the element on positions `i` in `currentRightSum`.

```cpp
for (int j = i + 1; j < nums.size(); j++) {
    currentRightSum += nums[j];
}
```

Then I compare the two calculated sums - for each element in the array and if the two sums are equal, it means that I have a PIVOT element and I have to return its position in the array.

```cpp
    if (currentRightSum == currentLeftSum) {
        return i;
    }
```

If I traverse the entire vector and find no pivot, I return `-1`.

The algorithm can be optimized

```cpp
int pivotIndex(vector<int>& nums) {
    int totalSum = accumulate(nums.begin(), nums.end(), 0);
    int leftSum = 0;
    
    for (int i = 0; i < nums.size(); i++) {
        if (leftSum == totalSum - leftSum - nums[i]) {
            return i;
        }
        leftSum += nums[i];
    }
    
    return -1;
}

```

In this algorithm, I initialize `totalSum` to the sum of all elements in the array quickly calculated using the `accumulate()` function from the `<numeric>` library. It is an extremely useful function for performing accumulation operations on the elements of a collection, such as vectors or arrays. It receives 3 input parameters: the beginning of the interval to be accumulated, the end of the interval to be accumulated and the initial value of the accumulation, i.e. the value from which the amount starts.

I then initialize `leftSum` to zero and loop through the entire array. At each iteration, however, I check if the sum on the left `leftSum` is equal to the sum on the right which I calculate using a simple mathematical relation like `totalSum - leftSum - nums[i]`.

If this condition is met, `i` is the pivot and we return it. Otherwise, I update `leftSum` with the current value of `nums[i]`.

If I traverse the entire vector and find no pivot, I return `-1`.

In conclusion, the `pivotIndex` function efficiently uses the algorithm to find the pivot in an array of integers, by means of a direct approach, which requires two traversals of the array for each element and an additional optimization using a single traversal and the calculation of the sums partial.

The original algorithm uses a brute-force approach to find the pivot, computing the left and right sums for each element, resulting in `O(n^2)` time complexity. Further optimization reduces this complexity to `O(n)` by using a single pass and the computation of partial sums.

Thus, the optimized algorithm is much more efficient and can handle large arrays in a reasonable time, providing a practical and fast solution to the problem of finding the pivot in an array of integers.



Problema cere calcularea și returnarea indexului unui pivot într-un array de numere întregi `nums`.

Un pivot este definit ca un index în array pentru care suma elementelor din stânga este egală cu suma elementelor din dreapta. Dacă nu există un astfel de index, funcția returnează `-1`.

For: `nums = [1,7,3,6,5,6]`:
`i = 0`: `currentLeftSum = 0`, `currentRightSum = 27`
`i = 1`: `currentLeftSum = 1`, `currentRightSum = 20`
`i = 2`: `currentLeftSum = 8`, `currentRightSum = 17`
`i = 3`: `currentLeftSum = 11`, `currentRightSum = 11` => `return 3`

For: `nums = [1,2,3]`:
`i = 0`: `currentLeftSum = 0`, `currentRightSum = 5`
`i = 1`: `currentLeftSum = 1`, `currentRightSum = 3`
`i = 2`: `currentLeftSum = 3`, `currentRightSum = 0`
=> `return -1` because there is no index that satisfies the conditions in the problem statement.

Algoritmul propus de mine  realizeaza o parcurgere completa a array-ului pe toata lungima sa `for (int i = 0; i < nums.size(); i++) {` folosind o bucla `for`. Variabila `i` reprezintă indexul curent pe care îl evaluăm pentru a determina dacă este un pivot.

```cpp
int currentLeftSum = 0;
int currentRightSum = 0;
```

Inițializez apoi două variabile temporare, `currentLeftSum` și `currentRightSum`, cu `0` pentru a stoca sumele elementelor din stânga și din dreapta indexului curent `i`.


Folosind o variabila index `j`, parcurg array-ul de la inceput pana inainte de pozitia curenta `i` si adun toate elementele din stanga elementului de pe pozitia `i` in `currentLeftSum`.

```cpp
for (int j = 0; j < i; j++) {
    currentLeftSum += nums[j];
}
```
In mod absolut similar, pornind de la succesorul elementului de pe pozitia `i` pana la finalul array-ului, calculez suma elementelor din dreapta elementului de pe poziti `i` in `currentRightSum`

```cpp
for (int j = i + 1; j < nums.size(); j++) {
    currentRightSum += nums[j];
}
```


Compar apoi cele doua sume calculate - pentru fiecare element din array si daca cele doua sume sunt egale inseamna ca am un element PIVOT si trebuie sa returnez pozitia lui in array.

```cpp
    if (currentRightSum == currentLeftSum) {
        return i;
    }
```

Dacă parcurg întregul vector și nu gasesc niciun pivot, returnez `-1`.

Algoritmul poate fi optimizat

```cpp
int pivotIndex(vector<int>& nums) {
    int totalSum = accumulate(nums.begin(), nums.end(), 0);
    int leftSum = 0;
    
    for (int i = 0; i < nums.size(); i++) {
        if (leftSum == totalSum - leftSum - nums[i]) {
            return i;
        }
        leftSum += nums[i];
    }
    
    return -1;
}

```

In aceast algoritm, initializez `totalSum` pe suma tuturor elementelor din array calculata rapid folosind functia `accumulate()` din libraria `<numeric>`. Este o functie extrem de utilă pentru a efectua operații de acumulare asupra elementelor unei colecții, cum ar fi vectori sau array-uri. Primeste 3 parametri de intrare: începutul intervalului de acumulat, sfârșitul intervalului de acumulat si valoarea inițială a acumulării, adică valoarea de la care începe suma.

Initializez apoi `leftSum` la zero și parcurg intregul array. La fiecare iteratie, verific insa dacă suma din stânga `leftSum` este egală cu suma din dreapta pe care o calculez folosind o relatie matematica simpla ca `totalSum - leftSum - nums[i]`.

Dacă această condiție este îndeplinită, `i` este pivotul și îl returnăm. Altfel, actualizez `leftSum` cu valoarea curentă `nums[i]`.

Dacă parcurg întregul vector și nu gasesc niciun pivot, returnez `-1`.

In concluzie, funcția `pivotIndex` utilizează eficient algoritmul de căutare a pivotului într-un array de numere întregi, prin intermediul unei abordări directe, care necesită două parcurgeri ale array-ului pentru fiecare element și o optimizare suplimentară folosind o singură parcurgere și calculul sumelor parțiale.

Algoritmul inițial utilizează o abordare de forță brută pentru a găsi pivotul, calculând sumele din stânga și din dreapta pentru fiecare element, ceea ce duce la o complexitate de timp `O(n^2)`. Optimizarea ulterioară reduce această complexitate la `O(n)` prin utilizarea unei singure parcurgeri și a calculului sumelor parțiale.

Astfel, algoritmul optimizat este mult mai eficient și poate gestiona array-uri mari într-un timp rezonabil, oferind o soluție practică și rapidă pentru problema găsirii pivotului într-un array de numere întregi.
