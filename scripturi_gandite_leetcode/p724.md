```cpp
class Solution {
public:
    int pivotIndex(vector<int>& nums) {
        for(int i=0;i<nums.size();i++){
            int currentLeftSum=0;
            int currentRightSum=0;
            //We calculate the sum of the elements to the left of i
            for(int j=0;j<i;j++){
                currentLeftSum+=nums[j];
            }

            //We calculate the sum of the elements to the right of i
            for(int j=i+1;j<nums.size();j++){
                currentRightSum+=nums[j];
            }
            
            //We check if the left and right sums are equal
            if(currentRightSum==currentLeftSum){
                // Return the pivot index if the condition is met
                return i;
            }
        }
        return -1;// Return -1 if there is no pivot
    }
};
```

!!!!!!!!!!!!!!!!REFACUT IN PARTEA DE JOS!!!!!!!!!!!!!!!

In this problem I receive a vector of integer values ​​and I am asked to return the power of the element in the vector (if it exists) that has the sum of the elements on its left identical to the sum of the elements on its right.
To solve this problem, I propose to go through the vector once from one end to the other and check the condition required by the problem for each individual element. If there is an element for which the condition of the problem is `true`, I return the index of the element. If the element does not exist, I am obliged to return `-1`.

For: `nums = [1,7,3,6,5,6]`:
`i = 0`: `currentLeftSum = 0`, `currentRightSum = 27`
`i = 1`: `currentLeftSum = 1`, `currentRightSum = 20`
`i = 2`: `currentLeftSum = 8`, `currentRightSum = 17`
`i = 3`: `currentLeftSum = 11`, `currentRightSum = 11` => `return 3`

For: `nums = [1,2,3]`:
`i = 0`: `currentLeftSum = 0`, `currentRightSum = 5`
`i = 1`: `currentLeftSum = 1`, `currentRightSum = 3`
`i = 2`: `currentLeftSum = 3`, `currentRightSum = 0`
=> `return -1` because there is no index that satisfies the conditions in the problem statement.


A step-by-step approach to solve this problem is:
1. Complete vector transversal.
2. Calculate the `currentLeftSum` and `currentRightSum` in each iteration.
3. Return the index for the pivot element.

So, let's take the steps one at a time.
1.Complete vector transversal:

I need two variables in this algorithm:
--- `currentLeftSum` variable which calculate the left sum for the element on the `i` position;
--- `currentRightSum` variable which calculate the right sum for the element on the `i` position.
These variables must be initialized to zero at the beginning of each iteration.

2. Calculate the `currentLeftSum` and `currentRightSum` in each iteration:

```cpp
    for(int j=0;j<i;j++){
        currentLeftSum+=nums[j];
    }
    for(int j=i+1;j<nums.size();j++){
        currentRightSum+=nums[j];
    }

```
For each element in the vector at position `i` I will use an iterator `j` that will go from 0 to the element at position `i-1` and calculate the `currentLeftSum` for element `i`.
Using the same iterator (no need to introduce a new iterator), I go with it this time from `i+1` to the right end of the vector (`nums.size()`) and calculate `currentRightSum`.
For each individual iteration, I check the condition required by the problem. If the two calculated values ​​are equal, it means that I have found a pivot element on the `i` position that I am returning.
If I reach the end of the vector and the condition was never met, it means I don't have a pivot element and I will return `-1`.

3. Return the maximum altitude:
```cpp
    if(currentRightSum==currentLeftSum){return i;}
    //} end of for loop
    return -1;
```

This is one solution to the problem, but to improve efficiency, one can use a single path of the vector to calculate the total sum and then traverse it to determine the left and right partial sum at each step.

```cpp
class Solution {
public:
    int pivotIndex(vector<int>& nums) {
        int sum=0;
        for(int i=0;i<nums.size();i++){
            sum+=nums[i];
        }
        for(int i=0;i<nums.size();i++){
            int currentLeftSum=0;
            for(int j=0;j<i;j++){
                currentLeftSum+=nums[j];
            }
            if(sum-currentLeftSum-nums[i]==currentLeftSum){return i;}
        }
        return -1;
    }
};

```

Iterates over the nums vector to calculate the total `sum` of the elements.
Iterates through the vector again, keeping a partial sum `currentLeftSum`.
At each step, it checks that `currentLeftSum` is equal to `sum-currentLeftSum-nums[i]` (which is the sum of the elements on the right).
If the condition is met, the current index `i` is returned.
If no such pivot index exists, `-1` is returned.

In conclusion, the original solution given for finding the pivot index in a vector iterates through each element and checks that the sum of the elements on the left is equal to the sum of the elements on the right.

To improve efficiency, you can calculate the total vector sum once and then use a single traversal to determine the left and right sums dynamically:

The improved solution has a time complexity of O(n) due to two simple traversals of the vector.
It also has O(1) space complexity because it only uses a few extra variables.

The original solution solves the problem correctly, but can be optimized. The improved solution demonstrates how calculating cumulative sums and maintaining a dynamic left sum can increase efficiency, making the solution more suitable for larger datasets.




!!!!!!!!!!!!!!!!!refacut!!!!!!!!!!!!!!!!!
Problema cere calcularea și returnarea indexului unui pivot într-un array de numere întregi `nums`.

Un pivot este definit ca un index în array pentru care suma elementelor din stânga este egală cu suma elementelor din dreapta. Dacă nu există un astfel de index, funcția returnează `-1`.

For: `nums = [1,7,3,6,5,6]`:
`i = 0`: `currentLeftSum = 0`, `currentRightSum = 27`
`i = 1`: `currentLeftSum = 1`, `currentRightSum = 20`
`i = 2`: `currentLeftSum = 8`, `currentRightSum = 17`
`i = 3`: `currentLeftSum = 11`, `currentRightSum = 11` => `return 3`

For: `nums = [1,2,3]`:
`i = 0`: `currentLeftSum = 0`, `currentRightSum = 5`
`i = 1`: `currentLeftSum = 1`, `currentRightSum = 3`
`i = 2`: `currentLeftSum = 3`, `currentRightSum = 0`
=> `return -1` because there is no index that satisfies the conditions in the problem statement.

Algoritmul propus de mine  realizeaza o parcurgere completa a array-ului pe toata lungima sa `for (int i = 0; i < nums.size(); i++) {` folosind o bucla `for`. Variabila `i` reprezintă indexul curent pe care îl evaluăm pentru a determina dacă este un pivot.

Calculul Sumelor din Stânga și Dreapta

cpp
Copy code
int currentLeftSum = 0;
int currentRightSum = 0;
Inițializăm două variabile, currentLeftSum și currentRightSum, la zero. Aceste variabile vor stoca sumele elementelor din stânga și din dreapta indexului curent i.

Calculul Sumei din Stânga

cpp
Copy code
for (int j = 0; j < i; j++) {
    currentLeftSum += nums[j];
}
Utilizăm un alt ciclu for pentru a parcurge toate elementele din stânga lui i (de la indexul 0 până la i-1) și adunăm aceste elemente la currentLeftSum.

Calculul Sumei din Dreapta

cpp
Copy code
for (int j = i + 1; j < nums.size(); j++) {
    currentRightSum += nums[j];
}
Similar, utilizăm un ciclu for pentru a parcurge toate elementele din dreapta lui i (de la indexul i+1 până la nums.size() - 1) și adunăm aceste elemente la currentRightSum.

Verificarea Condiției de Pivot

cpp
Copy code
if (currentRightSum == currentLeftSum) {
    return i;
}
Verificăm dacă currentLeftSum este egal cu currentRightSum. Dacă da, înseamnă că i este un pivot și îl returnăm imediat.

Returnarea Valorii -1 Dacă Nu Există Pivot

cpp
Copy code
return -1;
Dacă parcurgem întregul vector și nu găsim niciun pivot, returnăm -1.
