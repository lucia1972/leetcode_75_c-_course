```cpp
class Solution {
public:
    int uniquePaths(int m, int n) {
        // Create a 2D vector to store the number of unique paths to each cell
        vector<vector<int>> road(m, vector<int>(n, 0));

        // Initialize the first row and first column
        for (int i = 0; i < m; i++) {
            road[i][0] = 1;
        }
        for (int j = 0; j < n; j++) {
            road[0][j] = 1;
        }
        
        // Fill in the rest of the road vector
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                road[i][j] = road[i-1][j] + road[i][j-1];
            }
        }
        
         // The lower right corner contains the number of unique paths
        return road[m-1][n-1];
    }
};
```


Pe o grila `mxn` avem localizat în colțul din stânga sus adică `grid[0][0]` un robot care încearcă să se deplaseze până în colțul din dreapta jos adica `grid[m-1][n-1]`.
Miscarile acceptate pentru robot sunt în jos sau la dreapta.

Daca cunosc dimensiunile initiale ale grilei adica numerele intregi `m` si `n`, trebuie să returnez numărul de drumuri posibile dar unice pe care robotul le poate urma pentru a ajunge în colțul din dreapta jos.

Pentru a rezolva această problemă, pot apela din nou la programarea dinamică. Voi initializa un tablou bidimensional `road` cu `m` rânduri și `n` coloane, și toate elementele acestui tablou sunt nule initial.
Elementele de tipul `road[i][j]` reprezintă numărul de căi unice pentru a ajunge la celula `(i, j)` pornind de la celula `(0, 0)` a tabloului bidimensional.

Robotul poate să se deplaseze doar la dreapta pentru a ajunge la orice celulă din primul rând. Astfel, toate celulele din primul rând vor avea exact 1 cale unică de la început.

În mod similar, robotul poate să se deplaseze doar în jos pentru a ajunge la orice celulă din prima coloană. Astfel, toate celulele din prima coloană vor avea exact 1 cale unică de la început.

Conform datelor problemei, pentru orice altă celulă `(i, j)`, robotul poate să ajungă la această celulă fie din celula direct de deasupra ei `(i-1, j)`, fie din celula direct la stânga ei `(i, j-1)`. Prin urmare, numărul de căi unice pentru a ajunge la `(i, j)` este suma numărului de căi unice pentru a ajunge la `(i-1, j)` și `(i, j-1)`.

Voi popula prima linie si prima coloana a matricii cu valoarea `1`.

`for (int i = 0; i < m; i++) { road[i][0] = 1; }` - initializarea primului rând cu 1.

`for (int j = 0; j < n; j++) { road[0][j] = 1; }` - initializarea primei coloane cu 1.

Pentru celulele `(i, j)` care nu sunt pe marginea grilei, popularea matricii se poate face folosind relatia de recurenta `road[i][j] = road[i-1][j] + road[i][j-1]` iar valoarea retinuta la final in `road[m-1][n-1]` ne dă numărul total de căi unice de la stânga sus la dreapta jos.

Pentru `m = 3` si `n = 2` vom avea

`road[0][0] = 1`

`road[0][1] = 1`

`road[1][0] = 1`

`road[1][1] = road[0][1] + road[1][0] = 1 + 1 = 2`

`road[2][0] = 1`

`road[2][1] = road[1][1] + road[2][0] = 2 + 1 = 3`

deci matricea va fi 
1 1

1 2

1 3



