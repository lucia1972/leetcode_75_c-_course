```cpp
class Solution {
public:
    long long totalCost(vector<int>& costs, int k, int candidates) {
        int n = costs.size();

        // If the number of candidates is too large, we sort the array and take the first k elements
        if (candidates * 2 > n) {
            sort(costs.begin(), costs.end());
            return accumulate(costs.begin(), costs.begin() + k, 0LL);
        }

        using couple = pair<int, int>;
        priority_queue<couple, vector<couple>, greater<couple>> costIndex;

        // Add the first candidates and last candidates elements to the heap
        for (int i = 0; i < candidates; ++i) {
            costIndex.emplace(costs[i], i);
            costIndex.emplace(costs[n - i - 1], n - i - 1);
        }
        long long ans = 0;
        int l = candidates, r = n - candidates - 1;

        // Select k elements with minimum cost from the heap
        while (k--) {
            auto [cost, i] = costIndex.top();
            costIndex.pop();
            ans += cost;
            if (l > r) {
                continue;
            }
            if (i < l) {
                costIndex.emplace(costs[l], l++);
            } else {
                costIndex.emplace(costs[r], r--);
            }
        }
        return ans;
    }
};
```



Costurile angajarii unui grup de muncitori este retinut intr-un array `costs`. Fiecare element `costs[i]` reprezinta costul angajÄƒrii celui de-al `i`-lea muncitor.

Mi se cere ca in `k` sesiuni de angajare, unde `k` este un numar intreg cunoscut initial, sa angajez un numar de candidati dati ca si parametru de intrare in functia `totalCosts` in variabila integer `candidates`, astfel incat in fiecare sesiune de angajare voi lua lucrÄƒtorul cu cel mai mic cost fie dintre primii lucrÄƒtori candidaÈ›i, fie din ultimii lucrÄƒtori candidaÈ›i.

In final trebuie sa returnez costul total pentru a angaja cei `k` muncitori.

De exemplu, dacÄƒ `costs = [17,12,10,2,7,2,11,20,8]`, `k = 3` È™i `candidates = 2`

--- sesiune 1 de angajare voi alege al 3-lea muncitor `costs[3] = 2` pentru cÄƒ are cel mai mic cost - si `costs = [17,12,10,7,2,11,20,8]`;

--- sesiune 2 de angajare voi alege al patrulea lucrÄƒtor `costs[4] = 2` pentru cÄƒ are cel mai mic cost - si `costs = [17,12,10,7,11,20,8]`;

--- sesiune 3 de angajare voi alege al treilea lucrÄƒtor `costs[3] = 7` pentru cÄƒ are cel mai mic cost - si `costs = [17,12,10,11,20,8]`.

Deci costul total va fi `2 + 2 + 7 = 11`.


Pentru implementarea algoritmului de rezolvara a acestei probleme voi apela din nou la un `min-heap` (priority queue) pentru a selecta eficient cele mai mici costuri dintre primele valori din `candidates` È™i ultimele valori din `candidates` elemente din array-ul `costs`.

DacÄƒ `candidates * 2` este mai mare decÃ¢t lungimea array-ului, Ã®nseamnÄƒ cÄƒ practic toate elementele array-ului sunt considerate candidaÈ›i. Ãn acest caz, sortarea array-ului È™i selectarea primelor `k` elemente devine o soluÈ›ie simplÄƒ È™i directÄƒ.
Prin sortarea array-ului Ã®n ordine crescÄƒtoare È™i apoi luarea primelor `k` elemente, garantez cÄƒ selectez cele mai mici `k` costuri posibile. Aceasta este o abordare eficientÄƒ pentru a minimiza costul total atunci cÃ¢nd numÄƒrul de candidaÈ›i este suficient de mare Ã®ncÃ¢t sÄƒ acopere Ã®ntregul array sau aproape Ã®ntregul array.

```cpp
    int n = costs.size();
    if (candidates * 2 > n) {
        sort(costs.begin(), costs.end());
        return accumulate(costs.begin(), costs.begin() + k, 0LL);
    }
```

Definesc un `min-heap` (priority_queue) `costIndex` pentru a gestiona selecÈ›ia perechilor de cost È™i index.

Definitia pentru `couple` este o declaraÈ›ie de tip alias, care ne permite sÄƒ definim un alias pentru un tip existent. `pair<int, int>` este tipul pentru care definim alias-ul. Ãn acest caz, `couple` va reprezenta o pereche de Ã®ntregi `pair<int, int>`. Folosirea perechilor este convenabilÄƒ atunci cÃ¢nd dorim sÄƒ stocÄƒm douÄƒ valori legate Ã®ntre ele, cum ar fi un cost È™i indexul asociat acestuia.


```cpp 
using couple = pair<int, int>;
priority_queue<couple, vector<couple>, greater<couple>> costIndex;
```
Initializez 
Definim couple ca fiind o pereche de valori int (cost, index).
IniÈ›ializÄƒm un min-heap costIndex pentru a stoca perechile (cost, index).
AdÄƒugÄƒm primele candidates È™i ultimele candidates elemente Ã®n min-heap.
1. SelecÈ›ia Elementelor cu Cost Minim
IniÈ›ializÄƒm ans pentru a pÄƒstra suma totalÄƒ a costurilor minime.
l È™i r sunt indecÈ™ii pentru urmÄƒtoarele elemente care trebuie adÄƒugate Ã®n heap din partea stÃ¢ngÄƒ È™i dreaptÄƒ a array-ului.
Bucla while continuÄƒ pÃ¢nÄƒ cÃ¢nd am selectat k elemente:
Extragem perechea cu cel mai mic cost din heap.
AdÄƒugÄƒm costul la ans.
VerificÄƒm dacÄƒ am epuizat elementele din mijloc.
AdÄƒugÄƒm urmÄƒtorul element din stÃ¢nga sau dreapta Ã®n heap.
Concluzie
Algoritmul utilizeazÄƒ un min-heap pentru a gestiona eficient selecÈ›ia celor mai mici costuri din douÄƒ segmente diferite ale array-ului. Complexitatea temporalÄƒ a soluÈ›iei este dominatÄƒ de operaÈ›iunile de inserare È™i È™tergere Ã®n heap, fiecare avÃ¢nd o complexitate de 
ğ‘‚
(
log
â¡
ğ‘
ğ‘
ğ‘›
ğ‘‘
ğ‘–
ğ‘‘
ğ‘
ğ‘¡
ğ‘’
ğ‘ 
)
O(logcandidates). Ãn cel mai rÄƒu caz, complexitatea temporalÄƒ totalÄƒ a algoritmului este 
ğ‘‚
(
ğ‘›
log
â¡
ğ‘›
)
O(nlogn) datoritÄƒ sortÄƒrii iniÈ›iale, ceea ce Ã®l face eficient pentru majoritatea scenariilor practice. Utilizarea unui min-heap permite selectarea rapidÄƒ a celor mai mici costuri, asigurÃ¢nd cÄƒ soluÈ›ia gÄƒsitÄƒ este optimÄƒ.









