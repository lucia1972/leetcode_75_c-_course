```cpp
class Solution {
public:
    long long totalCost(vector<int>& costs, int k, int candidates) {
        int n = costs.size();

        // If the number of candidates is too large, we sort the array and take the first k elements
        if (candidates * 2 > n) {
            sort(costs.begin(), costs.end());
            return accumulate(costs.begin(), costs.begin() + k, 0LL);
        }

        using couple = pair<int, int>;
        priority_queue<couple, vector<couple>, greater<couple>> costIndex;

        // Add the first candidates and last candidates elements to the heap
        for (int i = 0; i < candidates; ++i) {
            costIndex.emplace(costs[i], i);
            costIndex.emplace(costs[n - i - 1], n - i - 1);
        }
        long long ans = 0;
        int l = candidates, r = n - candidates - 1;

        // Select k elements with minimum cost from the heap
        while (k--) {
            auto [cost, i] = costIndex.top();
            costIndex.pop();
            ans += cost;
            if (l > r) {
                continue;
            }
            if (i < l) {
                costIndex.emplace(costs[l], l++);
            } else {
                costIndex.emplace(costs[r], r--);
            }
        }
        return ans;
    }
};
```



Costurile angajarii unui grup de muncitori este retinut intr-un array `costs`. Fiecare element `costs[i]` reprezinta costul angajÄƒrii celui de-al `i`-lea muncitor.

Mi se cere ca in `k` sesiuni de angajare, unde `k` este un numar intreg cunoscut initial, sa angajez un numar de candidati dati ca si parametru de intrare in functia `totalCosts` in variabila integer `candidates`, astfel incat in fiecare sesiune de angajare voi lua lucrÄƒtorul cu cel mai mic cost fie dintre primii lucrÄƒtori candidaÈ›i, fie din ultimii lucrÄƒtori candidaÈ›i.

In final trebuie sa returnez costul total pentru a angaja cei `k` muncitori.

De exemplu, dacÄƒ `costs = [17,12,10,2,7,2,11,20,8]`, `k = 3` È™i `candidates = 2`

--- sesiune 1 de angajare voi alege al 3-lea muncitor `costs[3] = 2` pentru cÄƒ are cel mai mic cost - si `costs = [17,12,10,7,2,11,20,8]`;

--- sesiune 2 de angajare voi alege al patrulea lucrÄƒtor `costs[4] = 2` pentru cÄƒ are cel mai mic cost - si `costs = [17,12,10,7,11,20,8]`;

--- sesiune 3 de angajare voi alege al treilea lucrÄƒtor `costs[3] = 7` pentru cÄƒ are cel mai mic cost - si `costs = [17,12,10,11,20,8]`.

Deci costul total va fi `2 + 2 + 7 = 11`.


Pentru implementarea algoritmului de rezolvara a acestei probleme voi apela din nou la un `min-heap` (priority queue) pentru a selecta eficient cele mai mici costuri dintre primele valori din `candidates` È™i ultimele valori din `candidates` elemente din array-ul `costs`.

DacÄƒ `candidates * 2` este mai mare decÃ¢t lungimea array-ului, Ã®nseamnÄƒ cÄƒ practic toate elementele array-ului sunt considerate candidaÈ›i. Ãn acest caz, sortarea array-ului È™i selectarea primelor `k` elemente devine o soluÈ›ie simplÄƒ È™i directÄƒ.
Prin sortarea array-ului Ã®n ordine crescÄƒtoare È™i apoi luarea primelor `k` elemente, garantez cÄƒ selectez cele mai mici `k` costuri posibile. Aceasta este o abordare eficientÄƒ pentru a minimiza costul total atunci cÃ¢nd numÄƒrul de candidaÈ›i este suficient de mare Ã®ncÃ¢t sÄƒ acopere Ã®ntregul array sau aproape Ã®ntregul array.

```cpp
    int n = costs.size();
    if (candidates * 2 > n) {
        sort(costs.begin(), costs.end());
        return accumulate(costs.begin(), costs.begin() + k, 0LL);
    }
```

Definesc un `min-heap` (priority_queue) `costIndex` pentru a gestiona selecÈ›ia perechilor de cost È™i index.

`priority_queue<couple, vector<couple>, greater<couple>> costIndex;` 

Aceasta este o structurÄƒ de date din STL-ul C++ care implementeazÄƒ un heap.

Definitia pentru `couple` este o declaraÈ›ie de tip alias, care ne permite sÄƒ definim un alias pentru un tip existent. `pair<int, int>` este tipul pentru care definim alias-ul. Ãn acest caz, `couple` va reprezenta o pereche de Ã®ntregi `pair<int, int>`. Folosirea perechilor este convenabilÄƒ atunci cÃ¢nd dorim sÄƒ stocÄƒm douÄƒ valori legate Ã®ntre ele, cum ar fi un cost È™i indexul asociat acestuia.

```cpp 
using couple = pair<int, int>;
priority_queue<couple, vector<couple>, greater<couple>> costIndex;
```

Structura definita are deci elemente de tip `couple` iar `vector<couple>` specificÄƒ cÄƒ structura subiacenta folositÄƒ pentru stocarea elementelor este un vector de perechi.si `greater<couple>` specificÄƒ cÄƒ vreau sÄƒ folosesc un comparator pentru a transforma priority_queue Ã®ntr-un min-heap. FuncÈ›ia `greater` va organiza elementele Ã®n ordine crescÄƒtoare, astfel Ã®ncÃ¢t cel mai mic element sÄƒ fie Ã®n vÃ¢rful heap-ului.

Dupa definirea completa a acestei structuri,iniÈ›ializez min-heap-ul `costIndex` cu

--- primele elemente `candidates` adica `costIndex.emplace(costs[i], i);` adica adaug elementul din array-ul `costs` la poziÈ›ia `i` Ã®n heap. `costs[i]` reprezintÄƒ costul, iar `i` este indexul.

--- ultimele elemente `candidates` adica `costIndex.emplace(costs[n - i - 1], n - i - 1);` din array-ul `costs`, adica adaug elementul din array-ul `costs` de la poziÈ›ia `n - i - 1` Ã®n heap, unde `n - i - 1` reprezintÄƒ indexul ultimelor `candidates` din array.

```cpp 
    for (int i = 0; i < candidates; ++i) {
        costIndex.emplace(costs[i], i);
        costIndex.emplace(costs[n - i - 1], n - i - 1);
    }
```

Aceasta asigurÄƒ cÄƒ selecÈ›ia iniÈ›ialÄƒ a costurilor minime se face din aceste douÄƒ segmente ale array-ului.

FuncÈ›ia `emplace()` pe care am uitilizat-o aici este o metodÄƒ utilÄƒ disponibilÄƒ Ã®n multe containere din STL-ul C++, inclusiv Ã®n priority_queue. Ea permite inserarea unui nou element direct Ã®n container, construind elementul Ã®n locul de destinaÈ›ie, ceea ce poate fi mai eficient decÃ¢t inserarea unei copii a unui obiect deja construit.

Pentru a realiza selecÈ›ia elementelor cu cost minim trebuie sa initializez variabila de tip long long `ans` pentru a pÄƒstra suma totalÄƒ a costurilor minime, iar variabilele `l` È™i `r` sunt indecÈ™ii pentru urmÄƒtoarele elemente care trebuie adÄƒugate Ã®n heap din partea stÃ¢ngÄƒ È™i dreaptÄƒ a array-ului.

Folosind o structura reptitiva cu numar nedeterminat de pasi `while` voi itera continuu pana cand am selectat `k` elemente. Pornesc de la `k` dat si dupa fiecare iteratie il decrementez cu o unitate. Cand devine null, bucla este parasita dar deja am selectat `k` elemente.

Primul pas consta in accesarea perechii `(cost, i)` cu costul minim din heap fÄƒrÄƒ a o elimina.

Dupa ce am selectat-o si am retinut-o `auto [cost, i] = costIndex.top();` o pot elimina din heap `costIndex.pop();` si apoi incrementez variabila `ans` cu costul gasit in aceasta pereche.

Verific daca nu am ajunj la elementul din mijloc, adica dacÄƒ `l` (indexul curent din stÃ¢nga) este mai mare decÃ¢t `r` (indexul curent din dreapta), Ã®nseamnÄƒ cÄƒ am epuizat elementele din mijloc È™i nu mai avem elemente noi de adÄƒugat Ã®n heap.

```cpp
    if (l > r) {
        continue;
    }

```
DacÄƒ `i < l` adica indexul `i` al elementului extras din heap este mai mic decÃ¢t `l` Ã®nseamnÄƒ cÄƒ elementul provine din segmentul stÃ¢ng. AdÄƒug urmÄƒtorul element din segmentul stÃ¢ng Ã®n heap folosind `costIndex.emplace(costs[l], l++)`.
Altfel daca `i >= l` adica indexul `i` al elementului extras din heap este mai are sau egal cu `l` Ã®nseamnÄƒ cÄƒ elementul provine din segmentul drept. AdÄƒugm urmÄƒtorul element din segmentul drept Ã®n heap folosind `costIndex.emplace(costs[r], r--)`.

```cpp 
    if (i < l) {
        costIndex.emplace(costs[l], l++);
    } else {
        costIndex.emplace(costs[r], r--);
    }
```

VerificÄƒm dacÄƒ am epuizat elementele din mijloc.
AdÄƒugÄƒm urmÄƒtorul element din stÃ¢nga sau dreapta Ã®n heap.
Concluzie
Algoritmul utilizeazÄƒ un min-heap pentru a gestiona eficient selecÈ›ia celor mai mici costuri din douÄƒ segmente diferite ale array-ului. Complexitatea temporalÄƒ a soluÈ›iei este dominatÄƒ de operaÈ›iunile de inserare È™i È™tergere Ã®n heap, fiecare avÃ¢nd o complexitate de 
ğ‘‚
(
log
â¡
ğ‘
ğ‘
ğ‘›
ğ‘‘
ğ‘–
ğ‘‘
ğ‘
ğ‘¡
ğ‘’
ğ‘ 
)
O(logcandidates). Ãn cel mai rÄƒu caz, complexitatea temporalÄƒ totalÄƒ a algoritmului este 
ğ‘‚
(
ğ‘›
log
â¡
ğ‘›
)
O(nlogn) datoritÄƒ sortÄƒrii iniÈ›iale, ceea ce Ã®l face eficient pentru majoritatea scenariilor practice. Utilizarea unui min-heap permite selectarea rapidÄƒ a celor mai mici costuri, asigurÃ¢nd cÄƒ soluÈ›ia gÄƒsitÄƒ este optimÄƒ.









