```cpp
class Solution {
public:
    long long totalCost(vector<int>& costs, int k, int candidates) {
        int n = costs.size();

        // If the number of candidates is too large, we sort the array and take the first k elements
        if (candidates * 2 > n) {
            sort(costs.begin(), costs.end());
            return accumulate(costs.begin(), costs.begin() + k, 0LL);
        }

        using couple = pair<int, int>;
        priority_queue<couple, vector<couple>, greater<couple>> costIndex;

        // Add the first candidates and last candidates elements to the heap
        for (int i = 0; i < candidates; ++i) {
            costIndex.emplace(costs[i], i);
            costIndex.emplace(costs[n - i - 1], n - i - 1);
        }
        long long ans = 0;
        int l = candidates, r = n - candidates - 1;

        // Select k elements with minimum cost from the heap
        while (k--) {
            auto [cost, i] = costIndex.top();
            costIndex.pop();
            ans += cost;
            if (l > r) {
                continue;
            }
            if (i < l) {
                costIndex.emplace(costs[l], l++);
            } else {
                costIndex.emplace(costs[r], r--);
            }
        }
        return ans;
    }
};
```



Costurile angajarii unui grup de muncitori este retinut intr-un array `costs`. Fiecare element `costs[i]` reprezinta costul angajării celui de-al `i`-lea muncitor.

Mi se cere ca in `k` sesiuni de angajare, unde `k` este un numar intreg cunoscut initial, sa angajez un numar de candidati dati ca si parametru de intrare in functia `totalCosts` in variabila integer `candidates`, astfel incat in fiecare sesiune de angajare voi lua lucrătorul cu cel mai mic cost fie dintre primii lucrători candidați, fie din ultimii lucrători candidați.

In final trebuie sa returnez costul total pentru a angaja cei `k` muncitori.

De exemplu, dacă `costs = [17,12,10,2,7,2,11,20,8]`, `k = 3` și `candidates = 2`

--- sesiune 1 de angajare voi alege al 3-lea muncitor `costs[3] = 2` pentru că are cel mai mic cost - si `costs = [17,12,10,7,2,11,20,8]`;

--- sesiune 2 de angajare voi alege al patrulea lucrător `costs[4] = 2` pentru că are cel mai mic cost - si `costs = [17,12,10,7,11,20,8]`;

--- sesiune 3 de angajare voi alege al treilea lucrător `costs[3] = 7` pentru că are cel mai mic cost - si `costs = [17,12,10,11,20,8]`.

Deci costul total va fi `2 + 2 + 7 = 11`.


Pentru implementarea algoritmului de rezolvara a acestei probleme voi apela din nou la un `min-heap` (priority queue) pentru a selecta eficient cele mai mici costuri dintre primele valori din `candidates` și ultimele valori din `candidates` elemente din array-ul `costs`.

Dacă `candidates * 2` este mai mare decât lungimea array-ului, înseamnă că practic toate elementele array-ului sunt considerate candidați. În acest caz, sortarea array-ului și selectarea primelor `k` elemente devine o soluție simplă și directă.
Prin sortarea array-ului în ordine crescătoare și apoi luarea primelor `k` elemente, garantez că selectez cele mai mici `k` costuri posibile. Aceasta este o abordare eficientă pentru a minimiza costul total atunci când numărul de candidați este suficient de mare încât să acopere întregul array sau aproape întregul array.

```cpp
    int n = costs.size();
    if (candidates * 2 > n) {
        sort(costs.begin(), costs.end());
        return accumulate(costs.begin(), costs.begin() + k, 0LL);
    }
```

Definesc un `min-heap` (priority_queue) `costIndex` pentru a gestiona selecția perechilor de cost și index.

`priority_queue<couple, vector<couple>, greater<couple>> costIndex;` 

Aceasta este o structură de date din STL-ul C++ care implementează un heap.

Definitia pentru `couple` este o declarație de tip alias, care ne permite să definim un alias pentru un tip existent. `pair<int, int>` este tipul pentru care definim alias-ul. În acest caz, `couple` va reprezenta o pereche de întregi `pair<int, int>`. Folosirea perechilor este convenabilă atunci când dorim să stocăm două valori legate între ele, cum ar fi un cost și indexul asociat acestuia.

```cpp 
using couple = pair<int, int>;
priority_queue<couple, vector<couple>, greater<couple>> costIndex;
```

Structura definita are deci elemente de tip `couple` iar `vector<couple>` specifică că structura subiacenta folosită pentru stocarea elementelor este un vector de perechi.si `greater<couple>` specifică că vreau să folosesc un comparator pentru a transforma priority_queue într-un min-heap. Funcția `greater` va organiza elementele în ordine crescătoare, astfel încât cel mai mic element să fie în vârful heap-ului.

Dupa definirea completa a acestei structuri,inițializez min-heap-ul `costIndex` cu

--- primele elemente `candidates` adica `costIndex.emplace(costs[i], i);` adica adaug elementul din array-ul `costs` la poziția `i` în heap. `costs[i]` reprezintă costul, iar `i` este indexul.

--- ultimele elemente `candidates` adica `costIndex.emplace(costs[n - i - 1], n - i - 1);` din array-ul `costs`, adica adaug elementul din array-ul `costs` de la poziția `n - i - 1` în heap, unde `n - i - 1` reprezintă indexul ultimelor `candidates` din array.

```cpp 
    for (int i = 0; i < candidates; ++i) {
        costIndex.emplace(costs[i], i);
        costIndex.emplace(costs[n - i - 1], n - i - 1);
    }
```

Aceasta asigură că selecția inițială a costurilor minime se face din aceste două segmente ale array-ului.

Funcția `emplace()` pe care am uitilizat-o aici este o metodă utilă disponibilă în multe containere din STL-ul C++, inclusiv în priority_queue. Ea permite inserarea unui nou element direct în container, construind elementul în locul de destinație, ceea ce poate fi mai eficient decât inserarea unei copii a unui obiect deja construit.

Pentru a realiza selecția elementelor cu cost minim trebuie sa initializez variabila de tip long long `ans` pentru a păstra suma totală a costurilor minime, iar variabilele `l` și `r` sunt indecșii pentru următoarele elemente care trebuie adăugate în heap din partea stângă și dreaptă a array-ului.

Folosind o structura reptitiva cu numar nedeterminat de pasi `while` voi itera continuu pana cand am selectat `k` elemente. Pornesc de la `k` dat si dupa fiecare iteratie il decrementez cu o unitate. Cand devine null, bucla este parasita dar deja am selectat `k` elemente.

Primul pas consta in accesarea perechii `(cost, i)` cu costul minim din heap fără a o elimina.

Dupa ce am selectat-o si am retinut-o `auto [cost, i] = costIndex.top();` o pot elimina din heap `costIndex.pop();` si apoi incrementez variabila `ans` cu costul gasit in aceasta pereche.

Verific daca nu am ajunj la elementul din mijloc, adica dacă `l` (indexul curent din stânga) este mai mare decât `r` (indexul curent din dreapta), înseamnă că am epuizat elementele din mijloc și nu mai avem elemente noi de adăugat în heap.

```cpp
    if (l > r) {
        continue;
    }

```
Dacă `i < l` adica indexul `i` al elementului extras din heap este mai mic decât `l` înseamnă că elementul provine din segmentul stâng. Adăug următorul element din segmentul stâng în heap folosind `costIndex.emplace(costs[l], l++)`.
Altfel daca `i >= l` adica indexul `i` al elementului extras din heap este mai are sau egal cu `l` înseamnă că elementul provine din segmentul drept. Adăugm următorul element din segmentul drept în heap folosind `costIndex.emplace(costs[r], r--)`.

```cpp 
    if (i < l) {
        costIndex.emplace(costs[l], l++);
    } else {
        costIndex.emplace(costs[r], r--);
    }
```

Verificăm dacă am epuizat elementele din mijloc.
Adăugăm următorul element din stânga sau dreapta în heap.
Concluzie
Algoritmul utilizează un min-heap pentru a gestiona eficient selecția celor mai mici costuri din două segmente diferite ale array-ului. Complexitatea temporală a soluției este dominată de operațiunile de inserare și ștergere în heap, fiecare având o complexitate de 
𝑂
(
log
⁡
𝑐
𝑎
𝑛
𝑑
𝑖
𝑑
𝑎
𝑡
𝑒
𝑠
)
O(logcandidates). În cel mai rău caz, complexitatea temporală totală a algoritmului este 
𝑂
(
𝑛
log
⁡
𝑛
)
O(nlogn) datorită sortării inițiale, ceea ce îl face eficient pentru majoritatea scenariilor practice. Utilizarea unui min-heap permite selectarea rapidă a celor mai mici costuri, asigurând că soluția găsită este optimă.









