```cpp
class Solution {
public:
    long long totalCost(vector<int>& costs, int k, int candidates) {
        int n = costs.size();

        // If the number of candidates is too large, we sort the array and take the first k elements
        if (candidates * 2 > n) {
            sort(costs.begin(), costs.end());
            return accumulate(costs.begin(), costs.begin() + k, 0LL);
        }

        using couple = pair<int, int>;
        priority_queue<couple, vector<couple>, greater<couple>> costIndex;

        // Add the first candidates and last candidates elements to the heap
        for (int i = 0; i < candidates; ++i) {
            costIndex.emplace(costs[i], i);
            costIndex.emplace(costs[n - i - 1], n - i - 1);
        }
        long long ans = 0;
        int l = candidates, r = n - candidates - 1;

        // Select k elements with minimum cost from the heap
        while (k--) {
            auto [cost, i] = costIndex.top();
            costIndex.pop();
            ans += cost;
            if (l > r) {
                continue;
            }
            if (i < l) {
                costIndex.emplace(costs[l], l++);
            } else {
                costIndex.emplace(costs[r], r--);
            }
        }
        return ans;
    }
};
```



Costurile angajarii unui grup de muncitori este retinut intr-un array `costs`. Fiecare element `costs[i]` reprezinta costul angajării celui de-al `i`-lea muncitor.

Mi se cere ca in `k` sesiuni de angajare, unde `k` este un numar intreg cunoscut initial, sa angajez un numar de candidati dati ca si parametru de intrare in functia `totalCosts` in variabila integer `candidates`, astfel incat in fiecare sesiune de angajare voi lua lucrătorul cu cel mai mic cost fie dintre primii lucrători candidați, fie din ultimii lucrători candidați.

In final trebuie sa returnez costul total pentru a angaja cei `k` muncitori.

De exemplu, dacă `costs = [17,12,10,2,7,2,11,20,8]`, `k = 3` și `candidates = 2`

--- sesiune 1 de angajare voi alege al 3-lea muncitor `costs[3] = 2` pentru că are cel mai mic cost - si `costs = [17,12,10,7,2,11,20,8]`;

--- sesiune 2 de angajare voi alege al patrulea lucrător `costs[4] = 2` pentru că are cel mai mic cost - si `costs = [17,12,10,7,11,20,8]`;

--- sesiune 3 de angajare voi alege al treilea lucrător `costs[3] = 7` pentru că are cel mai mic cost - si `costs = [17,12,10,11,20,8]`.

Deci costul total va fi `2 + 2 + 7 = 11`.


Pentru implementarea algoritmului de rezolvara a acestei probleme voi apela din nou la un `min-heap` (priority queue) pentru a selecta eficient cele mai mici costuri dintre primele valori din `candidates` și ultimele valori din `candidates` elemente din array-ul `costs`.

Dacă `candidates * 2` este mai mare decât lungimea array-ului, înseamnă că practic toate elementele array-ului sunt considerate candidați. În acest caz, sortarea array-ului și selectarea primelor `k` elemente devine o soluție simplă și directă.
Prin sortarea array-ului în ordine crescătoare și apoi luarea primelor `k` elemente, garantez că selectez cele mai mici `k` costuri posibile. Aceasta este o abordare eficientă pentru a minimiza costul total atunci când numărul de candidați este suficient de mare încât să acopere întregul array sau aproape întregul array.

```cpp
    int n = costs.size();
    if (candidates * 2 > n) {
        sort(costs.begin(), costs.end());
        return accumulate(costs.begin(), costs.begin() + k, 0LL);
    }
```

Definesc un `min-heap` (priority_queue) `costIndex` pentru a gestiona selecția perechilor de cost și index.

Definitia pentru `couple` este o declarație de tip alias, care ne permite să definim un alias pentru un tip existent. `pair<int, int>` este tipul pentru care definim alias-ul. În acest caz, `couple` va reprezenta o pereche de întregi `pair<int, int>`. Folosirea perechilor este convenabilă atunci când dorim să stocăm două valori legate între ele, cum ar fi un cost și indexul asociat acestuia.


```cpp 
using couple = pair<int, int>;
priority_queue<couple, vector<couple>, greater<couple>> costIndex;
```
Initializez 
Definim couple ca fiind o pereche de valori int (cost, index).
Inițializăm un min-heap costIndex pentru a stoca perechile (cost, index).
Adăugăm primele candidates și ultimele candidates elemente în min-heap.
1. Selecția Elementelor cu Cost Minim
Inițializăm ans pentru a păstra suma totală a costurilor minime.
l și r sunt indecșii pentru următoarele elemente care trebuie adăugate în heap din partea stângă și dreaptă a array-ului.
Bucla while continuă până când am selectat k elemente:
Extragem perechea cu cel mai mic cost din heap.
Adăugăm costul la ans.
Verificăm dacă am epuizat elementele din mijloc.
Adăugăm următorul element din stânga sau dreapta în heap.
Concluzie
Algoritmul utilizează un min-heap pentru a gestiona eficient selecția celor mai mici costuri din două segmente diferite ale array-ului. Complexitatea temporală a soluției este dominată de operațiunile de inserare și ștergere în heap, fiecare având o complexitate de 
𝑂
(
log
⁡
𝑐
𝑎
𝑛
𝑑
𝑖
𝑑
𝑎
𝑡
𝑒
𝑠
)
O(logcandidates). În cel mai rău caz, complexitatea temporală totală a algoritmului este 
𝑂
(
𝑛
log
⁡
𝑛
)
O(nlogn) datorită sortării inițiale, ceea ce îl face eficient pentru majoritatea scenariilor practice. Utilizarea unui min-heap permite selectarea rapidă a celor mai mici costuri, asigurând că soluția găsită este optimă.









