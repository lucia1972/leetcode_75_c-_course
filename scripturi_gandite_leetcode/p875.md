```cpp 
class Solution {
public:
    int minEatingSpeed(vector<int>& piles, int h) {
        // Function that determines if Koko can eat all the bananas at rate k in h hours.
        auto canEatAll = [&](int k) {
            int hours = 0;
            for (int pile : piles) {
                hours += (pile + k - 1) / k; // Echivalent cu ceil(pile / k)
            }
            return hours <= h;
        };
        
        // Determine bounds for binary search
       int left = 1; // Minimum speed at which Koko can eat bananas
       int right = *max_element(piles.begin(), piles.end()); // The maximum speed is the largest heap

        // Binary search to find the minimum value of k
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (canEatAll(mid)) {
                right = mid; // Try a lower speed
            } else {
                left = mid + 1; // Increase speed because mid is not big enough
            }
        }
        
        return left; // left will be the minimum speed at which Koko can eat all the bananas in h hours
    }
};


```

In aceasta problema avem un array `piles` care contine gramezi de banane si un numar intreg `h` care reprezinta numarul de ore in care gardienii care pazezc bananele se intorc.

În fiecare oră, se alege o grămadă de banane și se mănâncă `k` banane din acel morman unde `k` reprezinta viteza cu care mananca bananele. Dacă grămada are mai puțin de `k` banane, se mănâncă toate cele `k` banane și nu se vor mai mânca alte banane în această oră.

Trebuie sa determin numărul întreg minim `k` astfel încât toate bananele sa poate fi mancate în decurs de `h` ore.


