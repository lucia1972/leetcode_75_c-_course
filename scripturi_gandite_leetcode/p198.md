```cpp
class Solution {
public:
    int rob(vector<int>& nums) {
        int n = nums.size();
        
        // If there are no cases, we return 0
        if (n == 0) return 0;
        
        // If there is only one house, return its value
        if (n == 1) return nums[0];
        
        // Array to store maximum amounts of money up to each house
        vector<int> money(n, 0);
        
        // Initialize the first two values
        money[0] = nums[0];
        money[1] = max(nums[0], nums[1]);
        
        // Calculate the maximum amounts for the rest of the houses
        for (int i = 2; i < n; i++) {
            money[i] = max(money[i-1], money[i-2] + nums[i]);
        }
        
        // Return the maximum amount of money that can be looted
        return money[n-1];
    }
};
```

Problema noastră presupune planificarea unui jaf de case de-a lungul unei străzi. Fiecare casă are o anumită sumă de bani ascunsă, dar există o constrângere: nu putem jefui două case adiacente în aceeași noapte deoarece sistemele de securitate ale acestora sunt conectate și vor alerta automat poliția dacă sunt jefuite simultan.

Ni se dă un array de numere întregi `nums` care reprezintă suma de bani din fiecare casă. Trebuie să returnăm suma maximă de bani pe care o putem jefui în această noapte fără a alerta poliția.

Pentru `nums = [1, 2, 3, 1]`

Putem jefui casa `0` cu `money = 1` și apoi casa `2` cu `money = 3`. Suma totală pe care o putem jefui este `1 + 3 = 4`.
Acesta este scenariul pentru a respecta cerinta problemei de a nu jefui case adiacente.

`casa 0` - `money = 1`

`casa 1` - `money = 2`

`casa 2` - `money = 3`

`casa 3` - `money = 1`

Dacă jefuim `casa 0` - `money = 1`, nu putem jefui casa 1. Trebuie să alegem între casele 2 și 3.

Dacă jefuim `casa 2` - `money = 3`, suma totală este `1 (din casa 0) + 3 (din casa 2) = 4`.

Dacă jefuim `casa 3` - `money = 1`, suma totală este `1 (din casa 0) + 1 (din casa 3) = 2`.

Dacă jefuim `casa 1` - `money = 2`, nu putem jefui casele 0 și 2. Ramane numai casa 3.

Dacă jefuim `casa 3` - `money = 1`, suma totală este `2 (din casa 1) + 1 (din casa 3) = 3`.

Deci, soluția optimă este să jefuim casa 0 și casa 2, deoarece suma totală de bani jefuiți este cea mai mare, adică 4.

Pentru a rezolva această problemă, putem utiliza o abordare de programare dinamică. Vom folosi un array auxiliar `money` pentru a memora suma maximă de bani pe care o putem obține până la fiecare casă, ținând cont de constrângerea de a nu jefui casele adiacente. Vom parcurge fiecare casă și vom decide dacă este mai avantajos să o jefuim sau nu, pe baza sumelor calculate anterior.

Putem incepe algoritmul cu 2 cazuri particulare pentru a simplifica logica principala a algoritmului:
--- daca nu exista case deloc - adică lungimea array-ului `nums` este 0, nu există nimic de jefuit. Este logic să returnăm `0` deoarece nu putem obține bani dintr-o stradă fără case.

--- daca exista o singura casa - singura opțiune este să jefuim acea casă. Prin urmare, suma maximă de bani pe care o putem obține este chiar valoarea din acea casă adica `nums[0]`.

Aceste două verificări ne permit să simplificăm scenariile în care numărul de case este foarte mic. După ce am tratat aceste cazuri, putem trece la logica principală a algoritmului, care se ocupă de situațiile în care există două sau mai multe case.

Pentru toate restul cazurilor va trebui sa calculam
Dacă nums este gol, returnăm 0 deoarece nu există case de jefuit.
Dacă există doar o casă, returnăm valoarea acesteia deoarece nu avem nicio constrângere.
Definirea array-ului de programare dinamică:
 // Dacă nu există case, returnăm 0
        if (n == 0) return 0;
        
        // Dacă există o singură casă, returnăm valoarea acesteia
        if (n == 1) return nums[0];


Vom folosi un array dp unde dp[i] reprezintă suma maximă de bani pe care o putem jefui până la casa i inclusiv.
Inițializăm dp[0] cu nums[0] și dp[1] cu maximul dintre nums[0] și nums[1].
Calcularea sumelor maxime pentru fiecare casă:

Pentru fiecare casă de la i = 2 până la n-1, calculăm dp[i] ca fiind maximul dintre:
Suma maximă de bani jefuită până la casa i-1 (dp[i-1]).
Suma maximă de bani jefuită până la casa i-2 plus valoarea casei curente (dp[i-2] + nums[i]).
Rezultatul final:

La sfârșitul parcurgerii, dp[n-1] va conține suma maximă de bani pe care o putem jefui fără a alerta poliția.
