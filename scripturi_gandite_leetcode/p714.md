```cpp
class Solution {
public:
    int maxProfit(vector<int>& prices, int fee) {
        int n = prices.size();
        if (n == 0) return 0;

        // maxProfit[i][0] - the maximum profit on the i-th day if we do not hold a stock
        // maxProfit[i][1] - the maximum profit on the i-th day if we hold a stock
        vector<vector<int>> maxProfit(n, vector<int>(2, 0));
        
        // Initial conditions
        maxProfit[0][0] = 0; // No stock on the first day
        maxProfit[0][1] = -prices[0]; // Holding stock on the first day

        for (int i = 1; i < n; ++i) {
            // If we don't hold stock today, it could be because we didn't hold it yesterday, or we sold it today
            maxProfit[i][0] = max(maxProfit[i-1][0], maxProfit[i-1][1] + prices[i] - fee);
            
            // If we hold stock today, it could be because we held it yesterday, or we bought it today
            maxProfit[i][1] = max(maxProfit[i-1][1], maxProfit[i-1][0] - prices[i]);
        }

        // The result is the maximum profit on the last day when we don't hold stock
        return maxProfit[n-1][0];
    }
};
```

In this problem, I receive an array of stock prices prices and an integer value fee representing a transaction fee that is charged for every transaction made. I can either buy or sell stocks, paying the corresponding fee for each sale. The goal is to determine the maximum profit I can achieve by completing as many transactions as I want. However, no two transactions can be carried out simultaneously.

To solve this problem, I will use a dynamic programming algorithm to maximize the profit from stock transactions while accounting for the transaction fee. I chose this approach because it allows me to break the problem down into smaller subproblems and combine their solutions to get the optimal solution for the initial problem. This approach is efficient and well-suited for optimization problems like this one.

The problem consists of maximizing profit from stock transactions over a period of time, given the constraints that I cannot perform simultaneous transactions and that I must pay a transaction fee for every sale. Because of the nature of this problem, where trading decisions depend on previous states (whether I held stocks on the previous day or not), dynamic programming is an appropriate approach.

If I initialize an integer variable `int n = prices.size();` for the size of the price vector, I can define a two-dimensional array using STL syntax: `vector<vector<int>> maxProfit(n, vector<int>(2, 0))`;

This matrix will be used to store the maximum profit on each day.

If `n == 0`, meaning there are no stocks, I will return 0 because there is no profit to calculate.

Initially:

`maxProfit[0][0] = 0;` — in the first day, without holding stocks, the profit is 0.
`maxProfit[0][1] = -prices[0];` — in the first day, holding stocks, the profit is negative and equal to the stock price on the first day.
After initializing the base conditions for day 0, we move on to calculating the maximum profit for each day using the following recurrence relations:

For not holding stocks on day i:

```cpp
maxProfit[i][0] = max(maxProfit[i-1][0], maxProfit[i-1][1] + prices[i] - fee);
```

If on day i I do not hold stocks, this can result from two situations:

Either I did not hold stocks on the previous day `maxProfit[i-1][0]`, or
I sold the stocks I held on the previous day, gaining profit from the sale `maxProfit[i-1][1] + prices[i] - fee`. In this case, I must subtract the transaction fee from the profit.
For holding stocks on day i:

```cpp
maxProfit[i][1] = max(maxProfit[i-1][1], maxProfit[i-1][0] - prices[i]);
```

If on day i I hold stocks, this can result from two situations:

Either I held them on the previous day `maxProfit[i-1][1]`, or
I bought stocks on day i, meaning I paid the stock price from the maximum profit obtained without holding stocks on the previous day `maxProfit[i-1][0] - prices[i]`.
These recurrence relations are used in a loop that goes through each day in the prices vector, starting from day 1 and going until the last day:

```cpp
for (int i = 1; i < n; ++i) {
    maxProfit[i][0] = max(maxProfit[i-1][0], maxProfit[i-1][1] + prices[i] - fee);
    maxProfit[i][1] = max(maxProfit[i-1][1], maxProfit[i-1][0] - prices[i]);
}
```

Through this loop, we calculate the maximum profit for each day, both for the case of not holding stocks and for holding them. Each day, the algorithm automatically decides whether it's better to buy, sell, or do nothing, depending on the maximum profit calculated from the previous day.

At the end, the maximum possible profit will be stored in `maxProfit[n-1][0]`, which is the maximum profit obtained on the last day when no stocks are held. This is the value we return:

```cpp
return maxProfit[n-1][0];
```

In the above version, we use a two-dimensional vector v to store the maximum profit for each day.

However, we can optimize the space used by this algorithm. Since each state maxProfit[i] only depends on the state `maxProfit[i-1]`, we can replace the maxProfit vector with two variables to store only the values from the previous day.

Thus, we can rewrite the main loop like this:

```cpp

int cash = 0;  // The maximum profit without holding stocks
int hold = -prices[0];  // The maximum profit while holding stocks

for (int i = 1; i < n; ++i) {
    cash = max(cash, hold + prices[i] - fee);
    hold = max(hold, cash - prices[i]);
}
```

In this case, the variable cash stores the maximum profit without stocks, and hold stores the maximum profit while holding stocks. Finally, we return the value stored in cash.

Through this dynamic programming algorithm, I was able to maximize the profit from stock transactions, taking into account the transaction fee and the constraint of not performing simultaneous transactions. The algorithm is efficient, with a time complexity of O(n) and, with space optimization, can run in O(1) space.

This approach demonstrates the power of dynamic programming in solving optimization problems, providing a clear and efficient solution to the problem of maximizing profit from stock transactions. It's important to understand how the problem was broken down into smaller subproblems and how the recurrence relations were used to build the final solution.





In aceasta problema primesc un array de preturi `prices` ale unor actiuni si o valoare intreaga `fee` care reprezinta o taxa de tranzactie care se percepe la fiecare tranzactie efectuata.
Pot cumpara sau pot vinde actiuni cu plata taxei corespunzatoare.
Trebuie sa determin care este profitul maxim pe care il pot obtine finalizand cate tranzactii doresc. 
Nu se pot realiza 2 tranzactii simultan.

Si pentru aceasta problema voi folosi un algoritm de programare dinamică pentru a rezolva problema maximizării profitului din tranzacții de acțiuni, ținând cont de o taxă de tranzacție. 
Am facut aceasta alegere deoarece imi permite să descompun problema în subprobleme mai mici și să combin soluțiile acestora pentru a obține soluția optimă la problema inițială. Această abordare este eficientă și potrivită pentru probleme de optimizare precum aceasta.

Problema constă în maximizarea profitului din tranzacții de acțiuni pe o perioadă de timp, având constrângerea că nu pot efectua tranzacții simultane și că trebuie să plătesc o taxă de tranzacție pentru fiecare vânzare. 
Datorită naturii acestei probleme, unde deciziile de tranzacționare depind de stările anterioare (deținere sau nu de acțiuni în ziua precedentă), programarea dinamică este o abordare potrivită.

Daca initializez o variabila intreaga `int n = prices.size();` pentru dimensiunea vectorului de prețuri pot defini si un tablou bidimensional folosind sintaxa STL.
`vector<vector<int>> maxProfit(n, vector<int>(2, 0));`

Aceasta matrice o voi folosi pentru a stoca profitul maxim în fiecare zi.

Daca `n==0` deci nu am deloc actiuni, voi returna `0` pentru ca nu am ce profit sa calculez.

Initial, 
`maxProfit[0][0] = 0;` - în prima zi, fără a deține acțiuni, profitul este `0`.
`maxProfit[0][1] = -prices[0];` - în prima zi, deținând acțiuni, profitul este negativ și egal cu prețul acțiunii în prima zi.

După ce am inițializat condițiile de bază pentru ziua `0`, vom trece la calculul profitului maxim pentru fiecare zi, folosind următoarele relații de recurență:

Pentru a nu deține acțiuni în ziua `i`:

```cpp
maxProfit[i][0] = max(maxProfit[i-1][0], maxProfit[i-1][1] + prices[i] - fee);
```

Dacă în ziua `i` nu deținem acțiuni, atunci acest lucru poate fi rezultatul a două situații:
--- fie nu am deținut acțiuni nici în ziua precedentă `maxProfit[i-1][0]`,
--- fie am vândut acțiunile pe care le dețineam în ziua precedentă, deci am obținut profitul din vânzare `maxProfit[i-1][1] + prices[i] - fee`.
În acest caz, trebuie să scădem taxa de tranzacție din profitul obținut.

Pentru a deține acțiuni în ziua `i`:

```cpp

maxProfit[i][1] = max(maxProfit[i-1][1], maxProfit[i-1][0] - prices[i]);
```

Dacă în ziua `i` deținem acțiuni, atunci acest lucru poate fi rezultatul a două situații:
--- fie le-am deținut și în ziua precedentă `maxProfit[i-1][1]`,
--- fie am cumpărat acțiuni în ziua `i`, deci am plătit prețul acțiunilor din profitul maxim obținut fără a deține acțiuni în ziua precedentă `maxProfit[i-1][0] - prices[i]`.

Aceste relații de recurență sunt folosite într-o buclă care parcurge fiecare zi din vectorul `prices`, începând de la ziua `1` și până la ultima zi.

```cpp

for (int i = 1; i < n; ++i) {
    maxProfit[i][0] = max(maxProfit[i-1][0], maxProfit[i-1][1] + prices[i] - fee);
    maxProfit[i][1] = max(maxProfitp[i-1][1], maxProfit[i-1][0] - prices[i]);
}
```

Prin această buclă, calculăm profitul maxim pentru fiecare zi, atât în cazul în care nu deținem acțiuni, cât și în cazul în care le deținem.
În fiecare zi, algoritmul decide automat dacă este mai bine să cumpărăm, să vindem sau să nu facem nimic, în funcție de profitul maxim calculat anterior.

La final, profitul maxim posibil se află în `maxProfit[n-1][0]`, adică profitul maxim obținut în ultima zi când nu mai deținem nicio acțiune.
Aceasta este valoarea pe care o returnăm.

```cpp

return maxProfit[n-1][0];
```

În varianta de mai sus, folosim un vector bidimensional `maxProfit` pentru a stoca profitul maxim pentru fiecare zi.

Totuși, putem optimiza spațiul folosit de acest algoritm.
Deoarece fiecare stare `maxProfit[i]` depinde doar de starea `maxProfit[i-1]`, putem înlocui vectorul `maxProfit` cu două variabile care să stocheze doar valorile din ziua anterioară.

Astfel, putem rescrie bucla principală astfel:

```cpp

int cash = 0; // Profitul maxim fără a deține acțiuni
int hold = -prices[0]; // Profitul maxim deținând acțiuni

for (int i = 1; i < n; ++i) {
    cash = max(cash, hold + prices[i] - fee);
    hold = max(hold, cash - prices[i]);
}
```

În acest caz, variabila `cash` stochează profitul maxim fără acțiuni, iar `hold` stochează profitul maxim deținând acțiuni. 
În final, returnăm valoarea retinuta in `cash`.


Prin acest algoritm de programare dinamică, am reușit să maximizăm profitul din tranzacțiile de acțiuni, ținând cont de taxa de tranzacție și de constrângerea de a nu efectua tranzacții simultane.
Algoritmul este eficient, cu o complexitate de timp `O(n)` și, prin optimizarea spațială, poate rula în spațiu `O(1)`.

Această abordare demonstrează puterea programării dinamice în rezolvarea problemelor de optimizare, oferind o soluție clară și eficientă pentru problema maximizării profitului din tranzacții de acțiuni.
Este important să înțelegem modul în care am descompus problema în subprobleme mai mici și cum am folosit relațiile de recurență pentru a construi soluția finală.