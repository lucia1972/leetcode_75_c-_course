**pentru scheme te poti inspira de aici https://www.educative.io/courses/grokking-coding-interview-patterns-python/linked-list-cycle**

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* deleteMiddle(ListNode* head) {
        //node = nod fictiv pentru a facilita manipularea listei, în special la ștergerea nodurilor.
        ListNode* node = new ListNode(0, head);
        // onePointer = pointer care se deplasează câte un nod la fiecare iterație.
        ListNode* onePointer = node;
        // twoPointer = pointer care se deplasează câte doua noduri la fiecare iterație.
        ListNode* twoPointer = head;
        while (twoPointer && twoPointer->next) {
            onePointer = onePointer->next;
            twoPointer = twoPointer->next->next;
        }
        onePointer->next = onePointer->next->next;
        return node->next;
    }
};

```

In aceasta problema primim o lista liniara simplu inlantuita de numere intregi pe care trebuie sa o modificam eliminandu-i nodul din mijloc.

O listă liniară înlănțuită (sau listă înlănțuită simplă) este o structură de date alcatuita dintr-o secvență de elemente numite noduri, unde fiecare nod conține două componente:

--- valoarea (sau datele): Reprezintă informația stocată în nod. Aceasta poate fi de orice tip: integer, string etc.
--- referința (sau pointerul): Este un pointer sau o referință la următorul nod din listă.

Caracteristici unei liste înlănțuite:
- dispune de o structură dinamică pentru ca dimensiunea listei se poate modifica dinamic prin adăugarea sau eliminarea nodurilor.
- operațiile de inserare și ștergere ale unui nod sunt eficiente și nu necesită rearanjarea elementelor, doar modificarea referințelor/pointerilor.
- accesul la elemente este secvențial și nu direct, ceea ce înseamnă că, pentru a accesa un element, trebuie parcurse toate elementele anterioare din listă.

Într-o listă înlănțuită simplă, fiecare nod pointează la următorul nod, iar ultimul nod pointează la `nullptr` sau `NULL`, indicând sfârșitul listei. Deși `NULL` și `nullptr` pot fi utilizate pentru a reprezenta un pointer nul, `nullptr` este preferat în C++ modern datorită avantajelor sale de claritate și siguranță a tipului. `nullptr` este un literal de tip pointer nul (nullptr_t) și este special conceput pentru a reprezenta un pointer null pentru ca clarifică intenția și elimină problemele de ambiguitate, deoarece nu poate fi confundat cu un integer.

Pentru rezolvarea acestei probleme, voi folosi tehnica cu 2 pointeri, unul in capul listei si unul in celalalt capat al ei. Ambii vin catre mijlocul listei si se opresc pe cel mai din mijloc nod.
Este una dintre cele mai simple si eficiente metode de a gasi mijlocul unui sir de valori. Am folosit deja tehnica si in alte probleme de pe Leetcode si nu numai.

Leetcode imi defineste initial cum arata lista mea pentru ca sa imi dea contextul in care imi solicita ei realizarea solutiei.

```cpp
struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

```

Fiecare nod conține o valoare val și un pointer next către următorul nod.

Eu am de realizat algoritmul care sa elimine nodul din mijlocul listei in functia `deleteMiddle`.

In prima parte am nevoie sa initializez pointerii cu care voi lucra:

```cpp
    //node = nod fictiv pentru a facilita manipularea listei, în special la ștergerea nodurilor.
    ListNode* node = new ListNode(0, head);
    // onePointer = pointer care se deplasează câte un nod la fiecare iterație.
    ListNode* oneNode = node;
    // twoPointer = pointer care se deplasează câte doua noduri la fiecare iterație.
    ListNode* twoPointer = head;
```

`node` este un nod nou fictiv cu valoarea `0` care pointează la `head`.
Acest nod ne ajută să gestionăm mai ușor ștergerea nodului din mijloc, inclusiv pentru cazurile când lista are doar două noduri.

`onePointer` si `twoPointer`, asa cum le spune si numele, sunt 2 pointeri.
`onePointer` este inițializat la nodul fictiv `node`.
`twoPointer` este inițializat la capul listei `head`.
Acesti pointeri ii voi folosi pentru a strabate lista.

