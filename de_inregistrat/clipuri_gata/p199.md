```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        vector<int> response;
        function<void(TreeNode*, int)> dfs = [&](TreeNode* node, int depth) {
            if (!node) {
                return;
            }
            if (depth == response.size()) {
                response.emplace_back(node->val);
            }
            dfs(node->right, depth + 1);
            dfs(node->left, depth + 1);
        };
        dfs(root, 0);
        return response;
    }
}; 

```
In this problem, our goal is to return the values of the nodes of a binary tree that are visible from the right side, ordered from top to bottom. The right-hand view consists of the nodes that are visible when looking at the tree from the right.

To achieve this, we will use a depth-first search (DFS) approach. This method helps us efficiently capture the rightmost nodes at each level of the tree.

Our solution involves a systematic traversal of the tree. We will keep track of the depth of each node and add the first node encountered at each depth to our output. By prioritizing the right child during the DFS traversal, we ensure that the rightmost nodes are processed first.

In a binary tree, each node is defined by a `TreeNode` structure. Each node contains an integer value and pointers to its left and right children.

We will create a class called `Solution` with a public member function named `rightSideView` that takes the root of the binary tree as a parameter and returns a vector of integers representing the right-side view of the tree. Inside this function, we will declare a `response` vector that will store the rightmost nodes at each level.

To perform the DFS traversal, we will define a `dfs` lambda function inside the `rightSideView` function. This `dfs` function takes two parameters: a pointer to a `TreeNode` (the current node) and an integer representing the current depth. The `dfs` function is designed to explore the rightmost subtree first, ensuring that the rightmost nodes are encountered before the leftmost nodes at each depth.

Within the `dfs` function, the first step is to check if the current node is null. If it is null, we simply exit the function, as there is nothing to process. 

Next, we check if the current depth is equal to the size of the response vector. If it is, it means that we have reached a new depth level, so we add the value of the current node to the `response` vector. 

Then, we recursively call the `dfs` function on the right child of the current node, incrementing the depth by one. After that, we call the `dfs` function on the left child of the current node with the same incremented depth. This traversal order ensures that the rightmost nodes are prioritized.

After defining the `dfs` function, we call it with the root node and an initial depth of zero to start the traversal. Finally, we return the `response` vector, which contains the values of the rightmost nodes at each level of the tree.

To summarize, our proposed solution involves systematically traversing the tree while keeping track of the depth of each node. By adding the first node encountered at each depth to the result vector and prioritizing the rightmost child during DFS traversal, we ensure that the rightmost nodes are processed first. This approach is both complexity-efficient and correct, allowing us to handle large-sized inputs in a reasonable amount of time.

In this solution, we ensure that the rightmost nodes at each level of the tree are captured efficiently, providing the desired right-side view. By using a depth-first search approach, we can traverse the tree in a manner that prioritizes the rightmost nodes, ensuring that we obtain the correct visualization from the right side of the tree. This method is effective in handling trees of various sizes and complexities, making it a robust solution for the problem at hand.

The systematic approach of tracking the depth and prioritizing the right children ensures that our solution is both time-efficient and accurate. We effectively navigate the tree and capture the necessary nodes for the right-side view, delivering the expected results in an optimal manner.