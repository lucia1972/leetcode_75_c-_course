```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* oddEvenList(ListNode* head) {
        ListNode* oddList = new ListNode(0); // nod fictiv pentru lista elementelor impare
        ListNode* evenList = new ListNode(0); // nod fictiv pentru lista elementelor pare
        ListNode* oddPointer = oddList;
        ListNode* evenPointer = evenList;
        
        ListNode* current = head;
        int index = 1;
        
        while (current) { // cât timp nu am ajuns la sfârșitul listei
            if (index % 2 == 1) { // verificăm dacă indexul este impar (poziția impară)
                oddPointer->next = current; // adăugăm nodul curent la lista nodurilor impare
                oddPointer = oddPointer->next; // mutăm pointerul la următorul nod din lista nodurilor impare
            } else { // dacă indexul este par (poziția pară)
                evenPointer->next = current; // adăugăm nodul curent la lista nodurilor pare
                evenPointer = evenPointer->next; // mutăm pointerul la următorul nod din lista nodurilor pare
            }
            
            current = current->next; // trecem la următorul nod din lista originală
            index++; // incrementăm indexul pentru a reflecta următoarea poziție în listă
        }
        
        // Închidem listele rezultate
        oddPointer->next = nullptr;
        evenPointer->next = nullptr;
        
        // Concatenăm listele
        oddPointer->next = evenList->next;
        
        // Returnăm lista rezultat (începutul listei impare)
        return oddList->next;

    }
};

```

In aceasta problema am o lista liniara inlantuita de valori intregi care trebuie rescrisa astfel incat, fara a modifica ordinea elementelor, primele elemente din lista sa fie cele care se gasesc pe pozitiile cu pointeri impari si apoi cele cu pointeri pari.

Voi folosi 2 liste ajutatoare `oddList` si `evenList` pe care le voi popula cu nodurile corespunzatoare si apoi le voi concatena impreuna pentru a obtine lista finala asa cum s-a cerut in problema.
Această metodă este simplă și eficientă din punct de vedere al complexității timpului, deoarece parcurg lista inițială o singură dată pentru a distribui nodurile în cele două liste ajutătoare și apoi fac o operație de concatenare, care este o operație liniară în funcție de dimensiunea listelor. In acest fel nu modific structura originală a listei decât prin rearanjarea elementelor în cele două liste ajutătoare.

Decizia de a folosi liste ajutătoare pentru a separa elementele în funcție de poziția lor este o abordare clară și intuitivă pentru rezolvarea problemei date.


In prima parte am nevoie sa fac cateva initializari:

```cpp
    ListNode* oddList = new ListNode(0); // nod fictiv pentru lista elementelor impare
    ListNode* evenList = new ListNode(0); // nod fictiv pentru lista elementelor pare
    ListNode* oddPointer = oddList;//folosit pentru a adăuga nodurile în lista oddList
    ListNode* evenPointer = evenList;//folosit pentru a adăuga nodurile în lista evenList
    
    ListNode* current = head;//
    int index = 1;//
```

`ListNode* oddList = new ListNode(0);` este un nod care va fi folosit pentru a construi lista finală a elementelor impare.

`ListNode* evenList = new ListNode(0);` este un nod care va fi folosit pentru a construi lista finală a elementelor pare.

`ListNode* oddPointer = oddList;` este un pointer folosit pentru a adăuga nodurile în lista `oddList`. La început, acesta pointează către nodul fictiv `oddList`.

`ListNode* evenPointer = evenList;` - este un pointer folosit pentru a adăuga nodurile în lista `evenList`. La început, acesta pointează către nodul fictiv `evenList`.

`ListNode* current = head;` este un pointer de lucru / temporar care pointează către capul listei inițiale `head`. Acesta si va fi folosit pentru a parcurge lista inițială și pentru a adăuga nodurile în listele `oddList` sau `evenList`.

`int index = 1;` este un index care va fi folosit pentru a determina dacă un nod se află pe o poziție impară sau pară în listă. Pozițiile impare vor avea `index % 2 == 1`, iar pozițiile pare vor avea `index % 2 == 0`.

Folosirea nodurilor fictive `oddList` și `evenList` este o tehnică utilă pentru manipularea listelor în timpul construcției lor, deoarece te ajută să eviți verificări suplimentare pentru primul nod și să gestionezi mai ușor cazurile speciale (cum ar fi lista goală sau adăugarea la început).

În continuare, trebuie să parcurgi lista head, să decizi unde să adaugi fiecare nod în funcție de index, să actualizezi pointerii oddPointer și evenPointer și, în final, să concatenezi listele oddList și evenList.

```cpp
    while (current) { // cât timp nu am ajuns la sfârșitul listei
        if (index % 2 == 1) { // verificăm dacă indexul este impar (poziția impară)
            oddPointer->next = current; // adăugăm nodul curent la lista nodurilor impare
            oddPointer = oddPointer->next; // mutăm pointerul la următorul nod din lista nodurilor impare
        } else { // dacă indexul este par (poziția pară)
            evenPointer->next = current; // adăugăm nodul curent la lista nodurilor pare
            evenPointer = evenPointer->next; // mutăm pointerul la următorul nod din lista nodurilor pare
        }

        current = current->next; // trecem la următorul nod din lista originală
        index++; // incrementăm indexul pentru a reflecta următoarea poziție în listă
    }
```

Parcurgem lista folosind o buclă `while` care rulează cât timp elementul `current` este diferit de `nullptr`, adică cât timp nu am ajuns la sfârșitul listei.

Separam elementele de pe pozitiile impare pentru care `index % 2 == 1` 

`oddPointer->next = current;` - si adăugăm nodul current la lista nodurilor impare, punându-l în `oddPointer->next`.

`oddPointer = oddPointer->next;` - Mutăm `oddPointer` la următorul nod din lista nodurilor impare pentru a fi pregătit pentru următorul nod adăugat.

Pentru elementele aflate pe pozitiile pare pentru care `index % 2 ==0` facem aceleasi operatii dar in lista `evenList` manevrand `evenPointer`.

Dupa ce am distribuit nodul curent in lista corespunzatoare, trecem la următorul nod din lista inițială, mutând `current` la `current->next`, adica `current = current->next;` si apoi incrementam valoarea indexului `index++;` pentru a evidentia poziția următorului nod în listă.

Cand termin de parcurs lista inițială, adica `current` ajunge sa fie la capatul listei, și am separat nodurile în listele `oddList` și `evenList`, vom lega lista nodurilor impare de cea a nodurilor pare, conform cerinței problemei.

Listele este important sa fie inchise la final:
```cpp
    // Închidem listele rezultate
    oddPointer->next = nullptr;
    evenPointer->next = nullptr;
```
Dacă nu faci aceste setari atunci nodurile din `oddList` și `evenList` vor avea legături nule către nodurile care le urmează, ceea ce ar duce la o listă rezultată care este o concatenare a listelor `oddList` și `evenList`, dar unde legăturile interne între noduri nu sunt terminate corespunzător.
În C++ și alte limbaje, o listă liniară simplu înlănțuită este reprezentată prin noduri care au un pointer către următorul nod în listă. Ultimul nod din listă ar trebui să aibă un pointer către `nullptr` pentru a indica sfârșitul listei.
De asemenea, in programarea orientată pe obiecte și în gestionarea memoriei, este o practică comună să setezi `next` al ultimului nod din listă la `nullptr` pentru ca structura listei să fie corect definită și să respecte convențiile standard si pentru a evita problemele de ciclare în timpul parcugerii sau manipulării listei.

Voi face o operatie simpla de concatenare : `oddPointer->next = evenList->next;`. Procedez in acest fel pentru ca `oddPointer->next` este pointerul care pointează la ultimul nod din `oddList`, iar `evenList->next` este pointerul către primul nod din evenList (primul nod real, nu nodul fictiv cu valoarea 0). Prin aceasta instructiune fac ca ultimul nod din `oddList` să pointeze către primul nod din `evenList` (sărind peste nodul fictiv). Altfel spus, pot spune ca spunem lista `oddList` trebuie să continue cu lista `evenList`, creând astfel o singură listă în care nodurile de pe pozițiile impare apar primele, urmate de nodurile de pe pozițiile pare.

Pentru lista `[2, 1, 3, 5, 6, 4, 7]` vreau sa vad efectiv cum decurge algoritmul:

Inițializare:

`head` = [2, 1, 3, 5, 6, 4, 7]``
`oddList` = [0] și `evenList` = [0]
`oddPointer` și `evenPointer` sunt inițializați la `oddList` și `evenList` respectiv.

Parcurgerea listei si separarea nodurilor :

Iterația 1 nodul cu valoarea 2 si `index = 1`: `oddList` = [0 -> 1], `oddPointer` este acum la 2 iar `evenPointer` este 0.
Iterația 2 nodul cu valoarea 1 si `index = 2`: `evenList` = [0 -> 2], `oddPointer` este acum la 2 iar `evenPointer` este 1.
Iterația 3 nodul cu valoarea 3 si `index = 3`: `oddList` = [0 -> 1 -> 3], `oddPointer` este acum la 3 iar `evenPointer` este 1.
Iterația 4 nodul cu valoarea 5 si `index = 4`: `evenList` = [0 -> 2 -> 5], `oddPointer` este acum la 3 iar `evenPointer` este acum la 5.
Iterația 5 nodul cu valoarea 6 si `index = 5`: `oddList` = [0 -> 1 -> 3 -> 6], `oddPointer` este acum la 6 iar `evenPointer` este acum la 5.
Iterația 6 nodul cu valoarea 4 si `index = 6`: `evenList` = [0 -> 2 -> 5 -> 4], `oddPointer` este acum la 6 iar `evenPointer` este acum la 4.
Iterația 7 nodul cu valoarea 7 si `index = 7`: `oddList` = [0 -> 1 -> 3 -> 6 -> 7], `oddPointer` este acum la 7 iar `evenPointer` este acum la 4.

Setez `oddPointer->next = nullptr` și `evenPointer->next = nullptr` pentru a închide listele.

Concatenez cele 2 liste:
`oddList` = [0 -> 2 -> 3 -> 6 -> 7] este concatenata cu `evenList` = [0 -> 1 -> 5 -> 4],
`oddPointer->next = evenList->next` leagă listele auxiliare.


In final returnez lista obtinuta.

In concluzie, acest algoritm foloseste o metoda simplă și intuitivă. Lista initiala este parcursa o singura data (O(n)) si ordinea elementelor este mentinuta ele fiind doar separate corect in functie de pozițiile impare și pare.


``` cpp
class Solution {
public:
    ListNode* oddEvenList(ListNode* head) {
        if (!head) return nullptr; // empty list check
        
        ListNode* oddList = new ListNode(0); // dummy node for odd nodes
        ListNode* evenList = new ListNode(0); // dummy node for even nodes
        ListNode* oddPointer = oddList;
        ListNode* evenPointer = evenList;
        
        ListNode* current = head;
        int index = 1;
        
        while (current) { // traverse the list
            if (index % 2 == 1) { // odd index
                oddPointer->next = current; // add to odd list
                oddPointer = oddPointer->next; // move odd pointer
            } else { // even index
                evenPointer->next = current; // add to even list
                evenPointer = evenPointer->next; // move even pointer
            }
            
            current = current->next; // move to the next node
            index++; // increment index
        }
        
        oddPointer->next = nullptr; // end odd list
        evenPointer->next = nullptr; // end even list
        
        oddPointer->next = evenList->next; // concatenate lists
        
        return oddList->next; // return reordered list head
    }
};
```


To solve the problem of reordering a singly linked list such that all nodes with odd indices come before all nodes with even indices, while maintaining their relative order, we can follow a structured approach. The solution should meet the requirements of *O(1)* extra space complexity and *O(n)* time complexity.

First, we initialize two dummy nodes, `oddList` and `evenList`, to serve as the starting points for the odd-indexed and even-indexed lists, respectively. These dummy nodes help in easily managing the head pointers of the resultant lists. We also initialize two pointers, `oddPointer` and `evenPointer`, to build the odd and even lists. Additionally, a `current` pointer is used to traverse the original list, and an `index` variable keeps track of the position of nodes (starting from 1 for the first node).

As we traverse the original linked list using the `current` pointer, we use the `index` variable to determine whether the node is at an odd or even position. If the node is at an odd position, we append it to the odd list using the `oddPointer`. Conversely, if the node is at an even position, we append it to the even list using the `evenPointer`. After processing each node, we move the `current` pointer to the next node and increment the `index`.

After the traversal is complete, the last nodes of both the odd and even lists should point to `nullptr` to mark the end of the lists. This step ensures that there are no residual links from the original list that might interfere with the reordered structure. Following this, we link the last node of the odd list to the first node of the even list to concatenate the two lists, forming the final reordered list.

The head of the reordered list is then set to the first node of the odd list, which is `oddList->next`. This head node represents the starting point of the reordered list that now has all odd-indexed nodes followed by all even-indexed nodes.

This approach ensures that we maintain the relative order of nodes within the odd and even groups and achieve the desired reordering in linear time and constant space. By using dummy nodes and a two-pointer traversal method, the solution is both efficient and straightforward. This method handles edge cases smoothly and ensures that the final list is correctly ordered according to the problem's requirements.

In conclusion, this algorithm effectively reorders a singly linked list by separating nodes into odd and even indexed groups and then concatenating these groups. The use of dummy nodes simplifies the process, and the single traversal of the list ensures that the solution is optimal. By maintaining the original relative order within the odd and even groups, the algorithm meets all specified constraints and performs efficiently.

Now, let's test this solution to ensure it works as expected before finalizing it. It's essential to explore different linked list configurations to verify the robustness of the algorithm. Testing with various list sizes, including edge cases like very short or very long lists, will help identify any potential issues and ensure that the solution handles all scenarios correctly. This thorough testing process is critical to validate the solution's accuracy and efficiency in reordering the linked list as required.