```cpp
class Solution {
public:
    bool closeStrings(string word1, string word2) {
        int frecv1[26]{};
        int frecv2[26]{};
        for (char& c : word1) {
            frecv1[c - 'a']++;
        }
        for (char& c : word2) {
            frecv2[c - 'a'];
        }
        for (int i = 0; i < 26; ++i) {
            if ((frecv1[i] == 0) != (frecv2[i] == 0)) {
                return false;
            }
        }
        sort(frecv1, frecv1 + 26);
        sort(frecv2, frecv2 + 26);
        return equal(frecv1, frecv1 + 26, frecv2);
    }
};
```

Hello and welcome to our Algorithmic course, where we will explore and solve interesting problems on LeetCode.

In this problem, I have 2 character strings `word1` and `word2`. These 2 strings are consider `CLOSE', if they start from one of them and reach the other by permutations and frequency changes between characters using the following operations:
1) Swap any two existing characters.
For example, `abcde` -> `aecdb`
2) Transform every occurrence of one existing character into another existing character, and do the same with the other character.
For example, `aacabb` -> `bbcbaa` (all a's turn into b's, and all b's turn into a's)

For `word1 = abc` and `word2 = bca`
The first operation: from `word1` I swap the last characters between them and I obtain `acb`.
The second operation: from `acb` I change the character `a` with `b` and obtain `bca`, I mean exactly `word2`.

Finally, I will return `true` or `false` if the words are considered `CLOSE`.

To solve this problem, I will use a 4-step algorithm:
--- the algorithm will count the character frequencies,
--- the algorithm will check if each character is present in both words `word1` and `word2`,
--- the two frequency vectors will be sorted and then compared between them
--- if all conditions are met, the words are considered `CLOSE` and the function returns `true`, otherwise it returns `false`.

A step-by-step approach to solve this problem is:

1. Initialization of the vectors for counting the appearance of characters in the initial words.
2. Counting the frequencies of characters in `word1`.
3. Counting the frequencies of characters in `word2`.
4. Checking the presence of characters.
5. Sorting and comparing frequency vectors.

So, let's take the steps one at a time.
1. Initialization of the vectors for counting the appearance of characters in the initial words:

```c++
    int frecv1[26]{};
    int frecv2[26]{};

```

In this first step, I will declare the vectors `frecv1` and `frecv2`, each of length 26, which are used to count the frequencies of each character in two words `word1` and `word2`.
Each position in these vectors corresponds to a letter of the English alphabet (a-z): for example, position 0 corresponds to the letter `a`, position 1 corresponds to the letter `b` and so on up to position 25 which corresponds to the letter `z`.
For each character in `word1`, the corresponding value in vector `frecv1` is incremented. For example, if `word1` contains the letter `z`, the value at position 25 of vector `frecv1` will be incremented.
Similarly, for each character in `word2`, the corresponding value in vector `frecv2` is incremented.

For `word1 = aab`
`frecv1 = [2,1,0,0,....,0]`;

2. Counting the frequencies of characters in `word1`: 

In this step, each character in `word1` is counted in the vector `frecv1`. The expression `c - 'a'` is used to map the character `c` to its position in the vector (for example `a` to 0, `b` to 1, etc.).

```c++
    for (char& c : word1) {
        frecv1[c - 'a']++;
    }
```

The `for` loop loops through each character `c` in the string `word1`.
The `char& c` reference is used to directly access each character in `word1`, streamlining access and changes.
To calculate the index of each character, I use `c - 'a'` which calculates the alphabetical position of the character `c`.
For example, for the letter `a`, `c - 'a'` is 0;
for the letter `b`, `c - 'a'` is 1, 
and so on to the letter `z`, where `c - 'a'` is 25.

`frecv1[c - 'a']++` increments the value from the `frecv1` vector at the calculated position, in other words, the frequency for each letter found is incremented accordingly and thus I can keep a correct record of the number of occurrences of each letter in `word1`.

3. Counting the frequencies of characters in `word2`: 

In this step, each character in `word2` is counted in the vector `frecv2`. The process is similar to step 2.

```c++
    for (char& c : word2) {
        frecv2[c - 'a']++;
    }
```

4. Checking the presence of characters:

```cpp
    for (int i = 0; i < 26; ++i) {
        if ((frecv1[i] == 0) != (frecv2[i] == 0)) {
            return false;
        }
    }
```

In this step, I also use a `for` loop that checks if the two words have the same letters present, regardless of the number of occurrences of each letter.
If a character is present in one of the words but absent in the other, the function returns `false`.

`for(int i = 0; i < 26; ++i)` is a loop that iterates from 0 to 25, to cover all positions in the frequency vectors `frecv1` and `frecv2`. Each position corresponds to a letter of the English alphabet (a-z).

The condition `if ((frecv1[i] == 0) != (frecv2[i] == 0))` is the comparison condition for the frequencies of the characters in the vectors `frecv1` and `frecv2` at position `i`.
`(freq1[i] == 0)` checks if the frequency of the corresponding character in `word1` is zero (ie the letter does not appear in `word1`).
`(freq2[i] == 0)` checks if the frequency of the corresponding character in `word2` is zero (ie the letter does not appear in `word2`).
The inequality operator `!=` compares the results of the two expressions. This operator gives a `true` or `false` answer.
The condition `(frecv1[i] == 0) != (frecv2[i] == 0)` is `true` if only one of the expressions is `true` (that is, the letter appears in only one word and not the other).
In other words, if the condition `(frecv1[i] == 0) != (frecv2[i] == 0)` is `true` for any `i`, it means that there is at least one letter that occurs in one of the words, but not in the other one.
In this case, return `false` is executed, indicating that the two words do not have the same sets of letters present.

5. Sorting and comparing frequency vectors:

```cpp
    sort(frecv1, frecv1 + 26);
    sort(frecv2, frecv2 + 26);
    return equal(frecv1, frecv1 + 26, frecv2);
```

This code sorts the frequency vectors `frecv1` and `frecv2` and then uses the `equal` function to compare whether they contain the same letter frequencies. This is useful for checking if two words are anagrams.

    
The sorting operation `sort(frecv1, frecv1 + 26);` for the first vector, is done using the `sort` function from the `<algorithm>` library. This sorts the elements between the `start` and `end` position. The range is delimited by `frecv1` - the beginning of the vector, and `frecv1 + 26` is the end of the vector (26 positions for each letter of the English alphabet).
`sort(frecv2, frecv2 + 26)` sorts the vector `frecv2` in the same way.

Using `equal(frecv1, ​​frecv1 + 26, frecv2)` we can very efficiently compare the vectors `frecv1` and `frecv2` to check if they contain the same elements in the same order.
The `equal` function is a function also found in the C++ standard library `<algorithm>` and checks if all the elements in the range `[frecv1, ​​frecv1 + 26)` are equal to the corresponding elements in the vector `frecv2`.

Finally, after all these operations, I can return the answer.
If the vectors are identical after sorting, the `equal` function returns `true`.
If the vectors differ at any position, the `equal` function returns `false`.

In conclusion, to check if two words are "CLOSE", the algorithm follows these steps:

Declare and initialize the vectors `frecv1` and `frecv2` to 0 to count the frequencies of each character in the two words.

The characters in `word1` and `word2` are traversed, incrementing the corresponding values ​​in the frequency vectors `frecv1` and `frecv2`.

Checks if all characters present in `word1` are also in `word2` and vice versa. If there is a character that appears in one word but not the other, the words are not "CLOSE".

The frequency vectors `frecv1` and `frecv2` are sorted. Then, the equal function is used to check if these vectors are identical.

If all these steps are met, the words are considered "CLOSE" and the function returns `true`. Otherwise, the function returns `false`.

This algorithm is efficient and ensures that two words are considered "CLOSE" if and only if they can be transformed into each other by permutations and exchanges of character frequencies according to the specified operations.

See you in the next video.


