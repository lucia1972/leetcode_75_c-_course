```cpp
class Solution {
public:
    int maxVowels(string s, int k) {
    
        string vowels( "aeiou" );
        //I count how many vowels there are in the first k characters in the string
        int contor = 0;
        for(int i=0;i<k;i++){
            if (vowels.find(s[i]) != string :: npos ) {
                contor++;
            }
        }
     
        int maxSequence = contor;
        
        // I drag the window along the string
        for (int i = k; i < s.size(); ++i) {
            // I add the new character that enters the window

            if (vowels.find(s[i]) != string :: npos ) {
                contor++;
            }
            // I subtract the character that comes out of the window
            if (vowels.find(s[i-k]) != string :: npos ) {
                contor--;
            }
            // I update the maximum number of vowels if necessary
            maxSequence = max(maxSequence, contor);
        }
        
        return maxSequence;
       
    }
};
```

Hello and welcome to our Algorithmic course, where we will explore and solve interesting problems on LeetCode.



This time I want to solve the problem of the maximum number of vowels in a substring of a certain length. For these I am given a string `s` and an integer `k` which represents the size of the substring I am looking for.

Problems involving substrings are usually problems that lend themselves to a solution using the sliding window technique.
If you are familiar with this algorithm, you already know that it is not extremely difficult.
If you don't know it, I'll explain it here briefly.
The "sliding window technique" could be explained as follows:
--- The initial "window" represents a substring of elements starting from position `0' of length k;
--- in the case of the present problem, we calculate the sum of the elements in this "window" and assume that it is the maximum sum;
--- we then move the window one element at a time and update the sum as the window slides, adding the new element that enters the `s[i]' window and removing the element that leaves the `s[i-k]` window;
--- in each iteration we update the maximum amount because that is ultimately the requirement of the problem.

A step-by-step approach to solve this problem is:
1. Count how many vowels I find in the first `k` characters of the string.
2. The algorithm slide the window from the beginning to the end of the array. For each new position of the window, update the window sum by subtracting the element that is leaving the window and adding the element that is entering the window. I update the maximum number of vowels if necessary.
3. The function returns the maximum number of vowels found in a substring of length `k`.


So, let's take the steps one at a time.
1. Count how many vowels I find in the first `k` characters of the string:

```cpp
        string vowels( "aeiou" );
        //I count how many vowels there are in the first k characters in the string
        int contor = 0;
        for(int i=0;i<k;i++){
            if (vowels.find(s[i]) != string :: npos ) {
                contor++;
            }
        }
```

The first step is to define a `vowels` string variable in which to store all the small vowels of the English language.
I need a whole variable `contor` in which to count how many vowels I find in the first `k` characters in the string.
So using a `for` loop, I go through the string over a length of `k` characters and using the `find()` method I search if the current character is a vowel or not.
The `find()` method is used to search for the first occurrence of the character `s[i]` in the string `vowels`. If the character is found, find returns the position at which the character was found in the vowel string. If the character is not found, find returns `string::npos` (invalid position).
`string::npos` is a static constant of type size_t (unsigned integer type, used for string indexing) that represents an impossible value for a valid position in a string.

2. The algorithm slide the window from the beginning to the end of the array. For each new position of the window, update the window sum by subtracting the element that is leaving the window and adding the element that is entering the window. I update the maximum number of vowels if necessary:

```cpp
        int maxSequence = contor;
        
        // I drag the window along the string
        for (int i = k; i < s.size(); ++i) {
            // I add the new character that enters the window

            if (vowels.find(s[i]) != string :: npos ) {
                contor++;
            }
            // I subtract the character that comes out of the window
            if (vowels.find(s[i-k]) != string :: npos ) {
                contor--;
            }
            // I update the maximum number of vowels if necessary
            maxSequence = max(maxSequence, contor);
        }

```

After counting the vowels in the first k characters, we store this count in the `maxSequence` integer variable.
I loop through the string `s` using the "sliding window technique" starting from position `k` to the end. In each iteration, I check if the new character added to the window is a vowel, and if so, increment the counter `contor`. I also check if the old character leaving the window was a vowel, and if so, decrement the counter `contor`.
Finally, I update `maxSequence` if the current counter `contor` is greater than the maximum value stored so far.

3. The function returns the maximum number of vowels found in a substring of length `k`.

```cpp
    return maxSequence;
```
Returns the maximum number of vowels found in a substring of length `k`.

In conclusion, this algorithm uses the "sliding window technique" to find the substring of length `k` that contains the most vowels. In the first step, it counts the vowels in the first `k` characters of the string. Then, using the sliding window, the algorithm adjusts the counter as the window moves along the string.
This method ensures that the solution has `O(n)` complexity, thus being efficient for large strings.

See you in the next video.

