```cpp
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int nonZero=0;
        for(int i=0;i<nums.size();i++){
            if (nums[i] != 0) {
                nums[nonZero] = nums[i];
                nonZero++;
            }
        }

        for (int i = nonZero; i < nums.size(); i++) {
            nums[i] = 0;
        }
    }
};
```
In this lesson, we are tackling the challenge of rearranging an integer array `nums` such that all zeros are shifted to the end while preserving the order of non-zero elements. The solution needs to be implemented in-place, meaning we modify the original array without using additional memory.

To achieve this transformation, we employ a strategic two-pointer technique. This approach optimizes the process by minimizing unnecessary operations and ensuring efficient traversal through the array.

We begin by initializing an integer variable `nonZero` to zero. This pointer serves as our tracker for the next position where a non-zero element should be placed within the array. As we iterate through `nums` using a loop, we inspect each element:

1. **Moving Non-Zero Elements**: When encountering a non-zero element at index `i`, we copy it to the position indicated by `nonZero` and then increment `nonZero`. This step effectively shifts all non-zero elements to the beginning of the array while maintaining their original relative order.

2. **Filling with Zeros**: Once all non-zero elements have been relocated to the front of the array, the next task is to ensure that the remaining positions in `nums` are filled with zeros. To accomplish this, we initiate a secondary loop starting from the index `nonZero`. Within this loop, we iterate through the remaining indices of `nums` and explicitly assign each element the value of zero. This step guarantees that all zeros are pushed to the end of the array after the non-zero elements.

By leveraging this two-pointer technique, we optimize the algorithm's performance with a linear time complexity of O(n), where `n` denotes the number of elements in `nums`. This efficiency is achieved by traversing the array a minimal number of times and ensuring that each element is processed exactly once. Moreover, the solution adheres strictly to the constraint of using constant extra space, demonstrating its practicality and effectiveness in solving real-world problems.

This solution not only addresses the problem requirements effectively but also provides insights into efficient algorithm design and implementation. By focusing on clarity and optimizing for performance, we ensure that the solution meets both functional and practical expectations in a software development context.