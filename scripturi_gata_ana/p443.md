```cpp
int compress(vector<char>& chars) {
        int poz = 0;  // Index for the position where we will write the compressed result
        for (int i = 0; i < chars.size();) {
            char current_char = chars[i];  // Current character
            int count = 0;

            // Counting consecutive occurrences of each character.
            t the number of times the current character appears
            while (i < chars.size() && chars[i] == current_char) {
                i++;
                count++;
            }

            // Write the current character at position k
            chars[poz++] = current_char;

            // If the character appears more than once, we also write the number of occurrences
            if (count > 1) {
                for (char c : to_string(count)) {
                    chars[poz++] = c;
                }
            }
        }
    // Return the new size of the compressed vector
    return poz;  
}

```
In this problem, I am given an array of characters `chars` that I need to compress using a specific algorithm. The algorithm involves processing consecutive repeating characters and appending them to a string `s` in a compressed format. If a character appears only once, I simply append the character to `s`. If it appears more than once, I append the character followed by its frequency count. The result is stored back in the `chars` array, and the algorithm must use only constant extra space. The final step is to return the new length of the `chars` array after compression.

First, I initialize an integer variable `poz` to zero. This variable keeps track of the position in the `chars` array where I will write the compressed result. I then start iterating through the `chars` array with an index variable `i`.

For each iteration, I capture the current character in `current_char` and initialize a counter `count` to zero. This counter will help me determine the number of consecutive appearances of `current_char`. I enter a while loop that continues as long as the current character matches `current_char` and the index `i` is within the bounds of the array. Inside this loop, I increment both `i` and `count`.

Once I exit the while loop, I write `current_char` to the `chars` array at the position `poz` and then increment `poz`. If `count` is greater than one, I convert `count` to a string and iterate through each character of this string, writing each digit to the `chars` array at the current position `poz` and incrementing `poz` for each digit.

This approach ensures that the `chars` array is modified in place, using only a constant amount of extra space as required. Finally, I return `poz`, which now represents the new length of the compressed array.

To sum up, I iterate through the `chars` array, count consecutive repeating characters, write the compressed results back to the `chars` array, and return the new length of the array. This ensures that the compression is done in place with constant space complexity.