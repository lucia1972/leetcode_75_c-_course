```cpp
int compress(vector<char>& chars) {
        int poz = 0;  // Index for the position where we will write the compressed result
        for (int i = 0; i < chars.size();) {
            char current_char = chars[i];  // Current character
            int count = 0;

            // Counting consecutive occurrences of each character.
            t the number of times the current character appears
            while (i < chars.size() && chars[i] == current_char) {
                i++;
                count++;
            }

            // Write the current character at position k
            chars[poz++] = current_char;

            // If the character appears more than once, we also write the number of occurrences
            if (count > 1) {
                for (char c : to_string(count)) {
                    chars[poz++] = c;
                }
            }
        }
    // Return the new size of the compressed vector
    return poz;  
}

```


Hello and welcome to our Algorithmic course, where we will explore and solve interesting problems on LeetCode.

In this problem, I receive a vector of characters that I have to compress.
For each group of identical consecutive characters:
--- If the length of the group is 1, append the character to the output string.
--- Otherwise, add the character followed by the length of the group.

I need to write an algorithm to determine a new comprimed vector and return the length of this new vector.

A step-by-step approach to solve this problem is:
1. Initializing an index to write the compressed output.
2. Traversing the character vector.
3. Counting consecutive occurrences of each character.
4. Writing the current character to the appropriate position in the vector.
5. If a character occurs more than once consecutively, writing the number of occurrences into the vector.
6. Return the new size of the compressed vector.

So, let's take the steps one at a time.
1. Initializing an index to write the compressed output:
```cpp
int poz = 0;
```
I initialize `poz` to 0 to track the write position in the vector.

2. Traversing the character vector:
```c++
for (int i = 0; i < chars.size();) {
    char current_char = chars[i];  // Current character
    int count = 0;

    // Count the number of times the current character appears
    while (i < chars.size() && chars[i] == current_char) {
        i++;
        count++;
    }

    // Write the current character at position k
    chars[poz++] = current_char;

    // If the character appears more than once, we also write the number of occurrences
    if (count > 1) {
        for (char c : to_string(count)) {
            chars[poz++] = c;
        }
    }
    }
```
In this problem, I need to compress a given array of characters `chars` using a specific algorithm and then return the new length of the array after compression. The algorithm works as follows: I will begin with an empty string `s`. For each group of consecutive repeating characters in `chars`, if the group's length is 1, I append the character to `s`; otherwise, I append the character followed by the group's length. 

The compressed string `s` should not be returned separately but instead stored in the input character array `chars`. Additionally, group lengths that are 10 or longer will be split into multiple characters in `chars`.

Let's delve into the detailed steps:

First, I initialize the variable `poz` to track the position in the `chars` array where I will write the compressed result. Then, I traverse the array `chars`, counting the consecutive occurrences of each character. For each group of consecutive characters, I write the character and, if necessary, the count of occurrences into the `chars` array. Finally, I return the new length of the compressed array.


To summarize, this solution efficiently compresses the array `chars` by iterating through it, counting consecutive characters, and writing the compressed form back into the array. The new length of the array is then returned, ensuring the algorithm operates in linear time complexity relative to the size of `chars`.