```cpp
class Solution {
public:
    bool increasingTriplet(vector<int>& nums) {
        int min1 = INT_MAX, min2 = INT_MAX;
        for (int n : nums) {
            if (n > min2) return true;
            if (n <= min1)
                min1 = n;
            else
                min2 = n;
        }
        return false;
    }
};
```
In this problem, I need to determine if there exists a triple of indices `(i, j, k)` in an integer array `nums` such that `i < j < k` and `nums[i] < nums[j] < nums[k]`. If such indices exist, I should return `true`. Otherwise, I should return `false`.

Let's break down the problem.

Given an integer array `nums`, my task is to check for the presence of three indices `i`, `j`, and `k` that satisfy the conditions `i < j < k` and `nums[i] < nums[j] < nums[k]`.

For instance, consider the array `nums = [1, 2, 3, 4, 5]`. Here:
- For `i = 0`, `j = 1`, and `k = 2`, we have `nums[0] = 1`, `nums[1] = 2`, and `nums[2] = 3`, which satisfies `i < j < k` and `nums[i] < nums[j] < nums[k]`. Hence, the function should return `true`.

On the other hand, consider the array `nums = [5, 4, 3, 2, 1]`. Here, no such triplet exists that satisfies the condition. Hence, the function should return `false`.

To solve this problem efficiently, I can use two variables `m1` and `m2` to keep track of the smallest and the second smallest numbers encountered so far. If I find a number greater than both `m1` and `m2`, then a triplet exists, and I return `true`.

The step-by-step approach would be to:

First, **initialize the variables**: I will initialize two variables `m1` and `m2` to `INT_MAX`, representing the smallest and the second smallest numbers encountered so far, respectively.

Then, to traverse the array: I will iterate through each element `num` in the array `nums`.
    - If `num` is less than or equal to `m1`, I update `m1` to `num`.
    - Else if `num` is less than or equal to `m2`, I update `m2` to `num`.
    - Else, it means `num` is greater than both `m1` and `m2`, so a valid triplet is found, and I return `true`.

And, finally, return result: If no such triplet is found during the traversal, I return `false`.

To summarize, this solution efficiently checks for the existence of an increasing triplet subsequence in the array `nums` using two variables `m1` and `m2` to track the smallest and the second smallest numbers encountered so far. By iterating through the array and updating these variables accordingly, I can determine if such a triplet exists in O(n) time complexity. If found, I return `true`; otherwise, I return `false`.