```cpp
  class Solution {
public:
    bool uniqueOccurrences(vector<int>& arr) {
        // Step 1: Count the occurrences of each number in the array
        unordered_map<int, int> countMap;
        for (int num : arr) {
            countMap[num]++;
        }

        // Step 2: Check if the occurrences are unique
        unordered_set<int> unicSet;
        for (auto& entry : countMap) {
            if (unicSet.find(entry.second) != unicSet.end()) {
                return false; // If an occurrence count is already in the set, it's not unique
            }
            unicSet.insert(entry.second);
        }
        // Step 3: Return the final answer
        return true;
    }
};
```

Hello and welcome to our Algorithmic course, where we will explore and solve interesting problems on LeetCode.

In this problem, if I have a string of numeric values ​​of integer type `arr`, I must return `true` if each element appears a unique number of times or `false` otherwise.

For `arr = [-3,0,1,-3,1,1,1,-3,10,0]`
The distinct elements are: `-3, 0, 1, 10`.
The element `-3` appears 3 times.
The element `0` appears 2 times.
The element `1` appears 4 times.
The element `10` appears 1 times.
So because 3 != 2 != 4 != 1, each element appears a unique number of times.

To solve this problem, I will use a 2-step algorithm:
At the beginning I will count how many times each number appears in the initial array. I will keep these counters in `count.Map`.
I will then check if the number of these occurrences is unique for each value.

A step-by-step approach to solve this problem is:

1. Count the occurrences of each number in the array.
2. Check if the occurrences are unique
3. Return the final answer

So, let's take the steps one at a time.
1. Count the occurrences of each number in the array:

In this first step, I will count how many times each number appears in the initial array.
To be more efficient, my algorithm uses an associative container `unordered_map<int, int> countMap`.
`unordered_map<>` is an associative container from the C++ standard library (STL) that stores components characterized by:
--- key - part of the element that establishes the order in which the element is stored in the container;
--- value - part of the element that represents the value assigned by the element with the paired key.
The key of an element is unique. In such a data collection there cannot be more than one element with the same key. If an attempt is made to insert an element with an already existing key, the value associated with that key will be overwritten.
We use `unordered_map<>` because the order of the elements is not important here and we want quick access to the elements through the keys. If we needed an ordered collection, we could use `map<>`.
Elements in `unordered_map<>` are not stored in a specific order. The order in which the elements are accessed can vary and does not follow the order of insertion.
Using this library is very efficient for situations where we need to search or insert elements quickly based on a key.
It is ideal for implementing data structures such as dictionaries, symbol tables and others that require fast lookups, being a very powerful and efficient container for managing key-value pairs in C++, providing excellent performance for most common operations due to its table-based implementation hash.

```c++
    unordered_map<int, int> countMap;
    for (int num : arr) {
        countMap[num]++;
    }
```

In the case of the present problem, `countMap` has keys of type `int` and values ​​of type `int`.

The `for` loop uses a range-based for loop to iterate through each num element in the `arr` vector. This type of loop simplifies iterating through the elements of a collection (such as vectors, lists, arrays, etc.) because it provides a more concise and readable syntax compared to the traditional for loop.
For each element with the key `num` in `arr`, the value associated with the key `num` in `countMap` is incremented.
If num does not already exist in `countMap`, a new entry will be created with an initial value of 0, which will then be incremented to 1.

For `arr = [-3,0,1,-3,1,1,1,-3,10,0]`
Step 1: `num = -3` so `countMap = {-3:1}`;
Step 2: `num = 0` so `countMap = {-3:1,0:1}`;
Step 3: `num = 1` so `countMap = {-3:1,0:1,1:1}`;
Step 4: `num = -3` so `countMap = {-3:2,0:1,1:1}`;
Step 5: `num = 1` so `countMap = {-3:2,0:1,1:2}`;
Step 6: `num = 1` so `countMap = {-3:2,0:1,1:3}`;
Step 7: `num = 1` so `countMap = {-3:2,0:1,1:4}`;
Step 8: `num = -3` so `countMap = {-3:3,0:1,1:4}`;
Step 9: `num = 10` so `countMap = {-3:3,0:1,1:4,10:1}`;
Step 10: `num = 0` so `countMap = {-3:3,0:2,1:4,10:1}`.

With this `countMap` determined I can move on to the next step.

2. Check if the occurrences are unique: 

In this step, I will check the uniqueness of the number of occurrences for each element present in the initial vector.

```c++
    unordered_set<int> unicSet;
    for (auto& entry : countMap) {
        if (unicSet.find(entry.second) != unicSet.end()) {
            return false; // If an occurrence count is already in the set, it's not unique
        }
        unicSet.insert(entry.second);
    }
```

I use an `unordered_set<int> unicSet` to check if the number of occurrences of each element in the `arr` vector is unique.
Why do I need this data structure?

An `unordered_set<>` allows me to store distinct values ​​and efficiently check if a value has already been added to the set.

In the case of this problem, I want to check if the number of occurrences of each element in `arr` is unique. If I encounter the same number of occurrences twice, it means that the occurrence numbers are not unique and I will return the answer `false`.
The search operation I need, in `unordered_set<>` has `O(1)` complexity, which makes the check fast.
Compared to other data structures (for example, a vector or a list), `unordered_set<>` provides a more efficient check for the presence of a value in the set being searched.

Using the `for` loop, I go through all the pairs (key, value) in `countMap`, i.e. `for (auto& entry : countMap)`.
Since `countMap` is an `unordered_map<>` that stores each element in the vector and its occurrence count, I will use `auto& entry` which is a reference to each (key, value) pair in `countMap`.

Then, using the statement `if (unicSet.find(entry.second) != unicSet.end()) {` I check if this number of occurrences (`entry.second`) already exists in unicSet.
`entry.first` is the number in the array, and `entry.second` is the number of occurrences of an element in the countMap.
Search for `entry.second` in `unicSet` using `unicSet.find(entry.second)`.
If `entry.second` is found in `unicSet`, i.e. if the expression `(unicSet.find(entry.second) != unicSet.end())` is `true`, it means that this number of occurrences is not unique and so I return `false`.
If the above expression is not true, so I do not return `false`, it means that I have uniqueness and using `unicSet.insert(entry.second);`' I insert `entrySecond` into `unicSet`.
In this way, I make sure that the following iterations will check the uniqueness of the number of occurrences with all the numbers of occurrences encountered previously.

3. Return the final answer:

```cpp 
    return true;
```

If we did not return `false` at all, it means that the final answer is `true`, that is, there are no duplicates in the number of occurrences.

In conclusion, to solve this problem, we used an efficient approach based on two C++ data structures: `unordered_map<>` and `unordered_set<>`.

`unordered_map<>` allowed us to quickly and efficiently count the occurrences of each element in the array.
`unordered_set<>` helped us check that these occurrence numbers are unique, making sure there are no duplicates.
By traversing the array to build the map of occurrences and then checking for their uniqueness in a set, our algorithm works in linear time with respect to the size of the array, thus providing an optimal and clear solution.

This algorithm can be used to solve similar problems involving counting and checking the uniqueness of elements in a collection, demonstrating the utility and power of these data structures in the C++ STL.

See you in the next video.


