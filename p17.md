**daca vrei detalii grafice gasesti si aici si te poti inspira https://www.educative.io/module/page/1j8yMXCkMj37LOGWX/10370001/4864305465655296/6549792358137856**

**aici ii ilustrata solutia, daca vrei sa te inspiri la partea grafica https://www.educative.io/module/page/1j8yMXCkMj37LOGWX/10370001/4864305465655296/4806207468208128  daca vrei sa intelegi**

```cpp
class Solution {
public:
    vector<string> letterCombinations(string digits) {
        if (digits.empty()) {
            return {};
        }

        vector<string> keys = {"abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
        vector<string> response;
        string current;

        // Funcția recursivă
        function<void(int)> backtrack = [&](int index) {
            if (index == digits.size()) {
                response.push_back(current);
                return;
            }

            string letters = keys[digits[index] - '2'];
            for (char c : letters) {
                current.push_back(c);
                backtrack(index + 1);
                current.pop_back();
            }
        };

        backtrack(0);
        return response;
    }
};

```

Combinatiile de litere ale unui numar de telefon.
Pe tastatura unui telefon exista atat litere cat si cifre.
Fiecare tasta are o cifra de la `0` la `9`. Succesiunile de litere sunt (faci o schema daca vrei eu le scriu aici sa iti fie mai usor)
1--->______
2--->abc
3--->def
4--->ghi
5--->jkl
6--->mno
7--->pqrs
8--->tuv
9--->wxyz

Problema garanteaza ca voi primi o combinatie de cifre formata numai din cifrele de la `2` la `9` si de asemenea ca nu voi avea o combinatie mai mare de 4 cifre.
Daca primesc un sir de cifre, problema cere sa returnez toate combinatiile posibile de litere pe care numarul le-ar putea reprezenta. Aceste combinatii pot fi prezentate in orice ordine.

Pentru a genera toate combinațiile posibile de litere corespunzătoare fiecărei cifre dintr-un șir, putem folosi o abordare recursivă care parcurge fiecare index al șirului. Pentru fiecare cifră, găsim literele corespunzătoare și le adăugăm la combinația curentă. Când lungimea combinației curente este egală cu lungimea șirului de cifre, adăugăm combinația la lista de combinații. După generarea unei combinații, eliminăm ultima literă din combinația curentă și explorăm alte combinații iterând prin literele rămase. În final, returnăm toate combinațiile posibile de litere generate din șirul de cifre dat.

Pasii:

Funcția verifică mai întâi dacă șirul de intrare este gol. Dacă este goală, vom returna imediat o listă goală.

```cpp
    if (digits.empty()) {
        return {};
    }
```
Acesta este un caz extrem, ca si in exemplul 2.

Daca sirul `digits` nu este gol, va trebui sa iau fiecare cifra a sa, sa gasesc grupul de litere care ii corespund si sa formez toate combinatiile posibile.
Pentru ca este nevoie sa gasesc toate combinatiile posibile, problema se preteaza la rezolvare prin metoda backtracking.

Backtracking-ul este o tehnică esențială în algoritmica și este adesea folosită în problemele combinatoriale datorită capacității sale de a explora spații de căutare mari și de a construi soluții valide pas cu pas. Utilizarea sa este justificată acolo unde este necesară generarea și explorarea soluțiilor posibile într-un mod eficient și controlat.

Backtracking-ul este o metodă recursivă care încearcă să construiască o soluție pas cu pas, alegând opțiuni valide în fiecare etapă și renunțând la o cale dacă se constată că aceasta nu duce la o soluție validă.

Abordarea backtracking utilizată în soluțiea de la aceasta problema, consideră o cifră ca punct de plecare și generează toate combinațiile posibile cu acea literă.
Cazul de bază pentru funcția de backtracking va fi că, dacă combinația noastră actuală de litere are aceeași lungime ca și cifrele introduse, iterația este completă.
În caz contrar, găsim toate combinațiile posibile de litere care corespund cifrei curente.

Inainte de a scrie efectiv functia recursiva de backtracking am nevoie de cateva initializari.

```cpp
    vector<string> keys = {"abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
    vector<string> response;
    string current;
```

`keys` este un array care conține literele corespunzătoare fiecărei cifre de la 2 la 9.
De exemplu, `2` este asociat cu "abc", `9` cu "wxyz", etc. 

De asemenea, se inițializează un array `response` care va conține toate combinațiile generate și un șir vid `current` care va fi folosit pentru a construi fiecare combinație în timpul backtracking-ului.


```cpp
    function<void(int)> backtrack = [&](int index) {
        if (index == digits.size()) {
            response.push_back(current);
            return;
        }

        string letters = keys[digits[index] - '2'];
        for (char c : letters) {
            current.push_back(c);
            backtrack(index + 1);
            current.pop_back();
        }
    };

```

Construiesc apoi o functie recursiva in care implementez algoritmul de backtracking.
Functia scrisa de mine este o functie de tip `void` care pri