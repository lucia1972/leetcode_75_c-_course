```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* oddEvenList(ListNode* head) {
        ListNode* oddList = new ListNode(0); // nod fictiv pentru lista elementelor impare
        ListNode* evenList = new ListNode(0); // nod fictiv pentru lista elementelor pare
        ListNode* oddPointer = oddList;
        ListNode* evenPointer = evenList;
        
        ListNode* current = head;
        int index = 1;
        
        while (current) {
            if (index % 2 == 1) {
                oddPointer->next = current;
                oddPointer = oddPointer->next;
            } else {
                evenPointer->next = current;
                evenPointer = evenPointer->next;
            }
            current = current->next;
            index++;
        }
        
        // Închidem listele rezultate
        oddPointer->next = nullptr;
        evenPointer->next = nullptr;
        
        // Concatenăm listele
        oddPointer->next = evenList->next;
        
        // Returnăm lista rezultat (începutul listei impare)
        return oddList->next;

    }
};

```




Explicație
Inițializăm listele auxiliare oddList și evenList cu un nod fictiv (0), care simplifică adăugarea nodurilor ulterioare.
Parcurgem lista inițială (head) folosind un pointer current și un index index. Adăugăm nodurile în oddList sau evenList în funcție de paritatea indexului.
După ce am separat toate nodurile, concatenăm oddList la evenList.
Returnăm oddList->next, care conține lista rezultată cu elementele de pe pozițiile impare urmate de cele de pe pozițiile pare.
Aceasta este o soluție eficientă cu o complexitate de timp de O(n), unde n este numărul de noduri din lista inițială, deoarece parcurgem lista o singură dată și operăm cu pointeri pentru adăugare și concatenare.