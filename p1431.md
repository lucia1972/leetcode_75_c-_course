```cpp
class Solution {
    public:
        vector<bool> kidsWithCandies(vector<int>& candies, int extraCandies) {
            int valMax = *max_element(candies.begin(),candies.end());
            vector <bool> result ;
            for(int c : candies){
                result.push_back(c+extraCandies >= valMax);
            }
        return result;
        }
};
```
**Partea 1**
In this problem, I have `n` kids with candies. I get an array `candies`, where `candies[i]` represents how many candies one `i th` child has. I also get an integer value, `extraCandies` which is the extra number of candies that each child will get.

Let's take a look at an example.

**Partea 2**
Let's say I have 5 children in `candies`. 
First one has 2 candies, second has 3, third has 5, fourth one has 1, and the fifth one has 3.
The one with the most candy is the third one. So, 5 is the max value.

Then, I give each child 3 extra candies. 
So the first child now has 5 candies, the second has 6, the third has 8, the fourth has 4, and the fifth has 6.
Now, I check if each child has more candies than the third child initially had. 
If he does, the answer is `true`. And, if he doesn't, the answer is `false`.

**Partea 3**
In C++, we can easily check this by using the `max_element()` function and a `for`.

If I was to describe the steps needed to solve this algorithm, I would first need to declare a variable, and the boolean array `result`. Then, I would give each child the `extraCandies` value and verify if the new amount of candy that the child has is more than the max value which we calculated. And, finally, I would return `result`.

So, first I declare an integer variable which I named `valMax`. This variable holds the max value. I calculate that max value, by using the function `max_element()` from the `<algorithm>` library. 
In general, this function gets 2 parameters: `first_index`, and `last_index`. 
So, it determines the max value of the array starting on the position of the `first_index` going to the `last_index`.
`max_element()` returns a pointer at which the max-value element is hosted. 
And for that, I use an asterisk. This is a specific C++ syntax. I would do a similar thing if I wanted the minimum element in the array, but by using `min_element()`.

I also declare the boolean array `result`: `vector <bool> result;`

**Partea 4**
My next step is to check the values after adding `extraCandies`. So, I'll use a `for` loop for this step. But, in order to be very efficient with my code, I add `extraCandies` and verify if that new amount is bigger than `valMax` then store the boolean answer of that in `result` all on the same line.
So, my `for` loop goes on each `c` in `candies`. This loop is known as a "range-based `for` loop". This type of loop traverses all the elements in a container, like an array or any other data structure that supports intervals.

The loop then, adds `extraCandies` to `c` and checks if the new `c` is bigger than `valMax`. Next, the loop adds that answer to `result` by using the `push_back` function

`push_back` comes from the `STL` library, and it's generally used to add a new element at the end of a container. If the container doesn't have enough capacity to store the added element, the capacity of the container will be automatically extended to accommodate the new element. This can be simply a relocation of the existing elements in the container.


**Partea 5**
In conclusion, to see if each child will have as many candies as the child with the most candies after adding extra candies, I first find the maximum initial candy count. Then, I check each child's candy count to see if adding extra candies makes it equal to or more than the maximum. The ultimate result is a list saying true or false for each child, showing if they meet this condition.

And now, let's run this solution to verify that everything works properly before submitting.
