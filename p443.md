```cpp
int compress(vector<char>& chars) {
        int poz = 0;  // Index for the position where we will write the compressed result
        for (int i = 0; i < chars.size();) {
            char current_char = chars[i];  // Current character
            int count = 0;

            // Coun
            t the number of times the current character appears
            while (i < chars.size() && chars[i] == current_char) {
                i++;
                count++;
            }

            // Write the current character at position k
            chars[poz++] = current_char;

            // If the character appears more than once, we also write the number of occurrences
            if (count > 1) {
                for (char c : to_string(count)) {
                    chars[poz++] = c;
                }
            }
        }
    // Return the new size of the compressed vector
    return poz;  
}

```


Hello and welcome to our Algorithmic course, where we will explore and solve interesting problems on LeetCode.

In this problem, I receive a vector of characters that I have to compress.
For each group of identical consecutive characters:
--- If the length of the group is 1, append the character to the output string.
--- Otherwise, add the character followed by the length of the group.

I need to write an algorithm to determine a new comprimed vector and return the length of this new vector.

A step-by-step approach to solve this problem is:
1. Initializing an index to write the compressed output.
2. Traversing the character vector.
3. Counting consecutive occurrences of each character.
4. Writing the current character to the appropriate position in the vector.
5. If a character occurs more than once consecutively, writing the number of occurrences into the vector.
6. Return the new size of the compressed vector.

So, let's take the steps one at a time.
1. Initializing an index to write the compressed output:
```cpp
int poz = 0;
```
I initialize `poz` to 0 to track the write position in the vector.

2. Traversing the character vector:
```c++
for (int i = 0; i < chars.size();) {
    char current_char = chars[i];  // Current character
    int count = 0;

    // Count the number of times the current character appears
    while (i < chars.size() && chars[i] == current_char) {
        i++;
        count++;
    }

    // Write the current character at position k
    chars[poz++] = current_char;

    // If the character appears more than once, we also write the number of occurrences
    if (count > 1) {
        for (char c : to_string(count)) {
            chars[poz++] = c;
        }
    }
    }
```
Using the repeating structure the vortex I am going from 0 to the size of the `chars` vector, iterating through the character vector. The size of the array is determined using the `size()` function.
For each iteration of the loop, I keep the current character of length `i` in the temporary variable `current_char`.
With the help of the `count` integer type variable, I will count for each character of the string, its number of occurrences. For this, at each re-entry into the loop, this counter must be reinitialized to restart the counting from 0.


3. Counting consecutive occurrences of each character:
While I haven't reached the end of the array and the character at position `i` is identical to the current character (`current_char`), I move further into the array (`i++`) and increment the count variable `count` because I found another character identical to the current character.

4. Writing the current character to the appropriate position in the vector:

When I exit this repetitive loop `while`, I have reached the last position in the character heaven that has the same character as the current character and I count how many identical characters I found. I store this information in the `chars` at position `pos` and increment the position `pos`. 
The line of code `chars[poz++] = current_char;` adds the current character to the `chars`, at `pos` position and also increments the variable `pos`.

5. If a character occurs more than once consecutively, writing the number of occurrences into the vector:

If the number of occurrences of the current character is greater than 1, I convert it to a string and write each character to the next position in `chars`.

6. Return the new size of the compressed vector:

```c++
return poz;  
```
Finally, I return the new size of the `chars` vector, which is the size of the compressed string.

The chars vector compression algorithm works by grouping and counting identical consecutive characters, writing the result directly into the original vector to minimize the use of extra space.
This algorithm is time efficient with O(n) complexity. The simplified and straightforward implementation provides efficient string compression without requiring the use of complex additional data structures.

See you in the next video.

**_Verificare daca se vede ce am modificat_**